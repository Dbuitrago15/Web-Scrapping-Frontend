"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-sse-stream.ts":
/*!*************************************!*\
  !*** ./src/hooks/use-sse-stream.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSEStream: () => (/* binding */ useSSEStream)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useSSEStream(param) {\n    let { batchId, onProgress, onResult, onComplete, onError, backendUrl = 'http://localhost:3000/api/v1' // Connect DIRECTLY to backend for SSE (proxy doesn't work)\n     } = param;\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hasCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false) // Prevent multiple connections\n    ;\n    // Stable refs for callbacks to avoid reconnection loops\n    const onProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onProgress);\n    const onResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onResult);\n    const onCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onComplete);\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            onProgressRef.current = onProgress;\n            onResultRef.current = onResult;\n            onCompleteRef.current = onComplete;\n            onErrorRef.current = onError;\n        }\n    }[\"useSSEStream.useEffect\"], [\n        onProgress,\n        onResult,\n        onComplete,\n        onError\n    ]);\n    // Polling fallback function\n    const startPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[startPolling]\": ()=>{\n            if (pollingIntervalRef.current || hasCompletedRef.current) {\n                return; // Already polling or completed\n            }\n            console.log('ðŸ”„ Starting polling fallback (every 2 seconds)');\n            pollingIntervalRef.current = setInterval({\n                \"useSSEStream.useCallback[startPolling]\": async ()=>{\n                    if (!batchId || hasCompletedRef.current) {\n                        stopPolling();\n                        return;\n                    }\n                    try {\n                        const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId));\n                        const data = await response.json();\n                        console.log('ðŸ“Š Polling update:', data.progress);\n                        // Update progress\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        // Check if completed\n                        if (data.status === 'completed') {\n                            console.log('âœ… Batch completed (detected via polling)');\n                            hasCompletedRef.current = true;\n                            if (onCompleteRef.current) {\n                                var _data_progress, _data_progress1;\n                                onCompleteRef.current({\n                                    batchId: data.batchId,\n                                    completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                    total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                    message: 'Batch processing completed',\n                                    timestamp: new Date().toISOString()\n                                });\n                            }\n                            stopPolling();\n                        }\n                    } catch (err) {\n                        console.error('âŒ Polling error:', err);\n                    }\n                }\n            }[\"useSSEStream.useCallback[startPolling]\"], 2000) // Poll every 2 seconds\n            ;\n        }\n    }[\"useSSEStream.useCallback[startPolling]\"], [\n        batchId\n    ]);\n    const stopPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[stopPolling]\": ()=>{\n            if (pollingIntervalRef.current) {\n                console.log('â¹ï¸ Stopping polling');\n                clearInterval(pollingIntervalRef.current);\n                pollingIntervalRef.current = null;\n            }\n        }\n    }[\"useSSEStream.useCallback[stopPolling]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[connect]\": ()=>{\n            if (!batchId || isConnectingRef.current || hasCompletedRef.current) {\n                console.log('âš ï¸ Skipping connection - batchId:', batchId, 'connecting:', isConnectingRef.current, 'completed:', hasCompletedRef.current);\n                return;\n            }\n            isConnectingRef.current = true;\n            console.log('ðŸ”Œ Connecting to SSE stream for batch:', batchId);\n            console.log('ðŸ“¡ Backend URL:', backendUrl);\n            // First, check if the batch is already complete\n            fetch(\"/api/v1/scraping-batch/\".concat(batchId)).then({\n                \"useSSEStream.useCallback[connect]\": (res)=>res.json()\n            }[\"useSSEStream.useCallback[connect]\"]).then({\n                \"useSSEStream.useCallback[connect]\": (data)=>{\n                    console.log('ðŸ“‹ Batch status:', data.status);\n                    if (data.status === 'completed') {\n                        console.log('âœ… Batch already completed, triggering onComplete with progress:', data.progress);\n                        hasCompletedRef.current = true;\n                        isConnectingRef.current = false;\n                        // Update progress immediately if we have the data\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage || 100,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        if (onCompleteRef.current) {\n                            var _data_progress, _data_progress1;\n                            onCompleteRef.current({\n                                batchId: data.batchId,\n                                completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                message: 'Batch processing already completed',\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        return; // Don't connect to SSE if already complete\n                    }\n                    // If not complete, connect to SSE\n                    try {\n                        const url = \"\".concat(backendUrl, \"/scraping-batch/\").concat(batchId, \"/stream\");\n                        console.log('ðŸ”— SSE URL:', url);\n                        const eventSource = new EventSource(url);\n                        eventSourceRef.current = eventSource;\n                        // Connected event\n                        eventSource.addEventListener('connected', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('âœ… SSE Connected:', data);\n                                setIsConnected(true);\n                                setError(null);\n                                isConnectingRef.current = false;\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Progress event\n                        eventSource.addEventListener('progress', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('ðŸ“Š SSE Progress:', data);\n                                if (onProgressRef.current) {\n                                    onProgressRef.current(data);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Result event (individual business result)\n                        eventSource.addEventListener('result', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const result = JSON.parse(event.data);\n                                console.log('ðŸ“¦ SSE Result:', result);\n                                if (onResultRef.current) {\n                                    onResultRef.current(result);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Complete event\n                        eventSource.addEventListener('complete', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('âœ… SSE Complete:', data);\n                                hasCompletedRef.current = true;\n                                if (onCompleteRef.current) {\n                                    onCompleteRef.current(data);\n                                }\n                                disconnect();\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Error event\n                        eventSource.addEventListener('error', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                if (event.data) {\n                                    const errorData = JSON.parse(event.data);\n                                    console.error('âŒ SSE Error event:', errorData);\n                                    setError(errorData.message);\n                                    if (onErrorRef.current) {\n                                        onErrorRef.current(errorData);\n                                    }\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Generic error handler with polling fallback\n                        eventSource.onerror = ({\n                            \"useSSEStream.useCallback[connect]\": (error)=>{\n                                console.error('âŒ SSE Connection error:', error);\n                                setIsConnected(false);\n                                setError('Connection lost. Switching to polling...');\n                                // If connection is closed, fallback to polling\n                                if (eventSource.readyState === EventSource.CLOSED) {\n                                    console.log('ðŸ”„ SSE closed, starting polling fallback');\n                                    disconnect();\n                                    startPolling();\n                                }\n                            }\n                        })[\"useSSEStream.useCallback[connect]\"];\n                    } catch (err) {\n                        console.error('âŒ Failed to create SSE connection:', err);\n                        setError('Failed to establish connection, using polling');\n                        setIsConnected(false);\n                        isConnectingRef.current = false;\n                        startPolling();\n                    }\n                }\n            }[\"useSSEStream.useCallback[connect]\"]).catch({\n                \"useSSEStream.useCallback[connect]\": (err)=>{\n                    console.error('âŒ Failed to check batch status:', err);\n                    setError('Failed to check batch status');\n                    isConnectingRef.current = false;\n                    startPolling() // Fallback to polling if status check fails\n                    ;\n                }\n            }[\"useSSEStream.useCallback[connect]\"]);\n        }\n    }[\"useSSEStream.useCallback[connect]\"], [\n        batchId,\n        backendUrl,\n        startPolling\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[disconnect]\": ()=>{\n            if (eventSourceRef.current) {\n                console.log('ðŸ”Œ Disconnecting SSE stream');\n                eventSourceRef.current.close();\n                eventSourceRef.current = null;\n                setIsConnected(false);\n            }\n            stopPolling();\n            isConnectingRef.current = false;\n            hasCompletedRef.current = false;\n        }\n    }[\"useSSEStream.useCallback[disconnect]\"], [\n        stopPolling\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            if (batchId) {\n                connect();\n            }\n            return ({\n                \"useSSEStream.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useSSEStream.useEffect\"];\n        // Only reconnect when batchId changes, not when callbacks change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSSEStream.useEffect\"], [\n        batchId\n    ]);\n    return {\n        isConnected,\n        error,\n        disconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utc3NlLXN0cmVhbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0U7QUFxQ3pELFNBQVNJLGFBQWEsS0FPUDtRQVBPLEVBQzNCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsYUFBYSwrQkFBK0IsMkRBQTJEO0lBQTVELEVBQ3ZCLEdBUE87SUFRM0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTWEsaUJBQWlCZCw2Q0FBTUEsQ0FBcUI7SUFDbEQsTUFBTWUscUJBQXFCZiw2Q0FBTUEsQ0FBd0I7SUFDekQsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBQyxPQUFPLCtCQUErQjs7SUFFckUsd0RBQXdEO0lBQ3hELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBQ0s7SUFDN0IsTUFBTWMsY0FBY25CLDZDQUFNQSxDQUFDTTtJQUMzQixNQUFNYyxnQkFBZ0JwQiw2Q0FBTUEsQ0FBQ087SUFDN0IsTUFBTWMsYUFBYXJCLDZDQUFNQSxDQUFDUTtJQUUxQixvQ0FBb0M7SUFDcENULGdEQUFTQTtrQ0FBQztZQUNSbUIsY0FBY0ksT0FBTyxHQUFHakI7WUFDeEJjLFlBQVlHLE9BQU8sR0FBR2hCO1lBQ3RCYyxjQUFjRSxPQUFPLEdBQUdmO1lBQ3hCYyxXQUFXQyxPQUFPLEdBQUdkO1FBQ3ZCO2lDQUFHO1FBQUNIO1FBQVlDO1FBQVVDO1FBQVlDO0tBQVE7SUFFOUMsNEJBQTRCO0lBQzVCLE1BQU1lLGVBQWVyQixrREFBV0E7a0RBQUM7WUFDL0IsSUFBSWEsbUJBQW1CTyxPQUFPLElBQUlOLGdCQUFnQk0sT0FBTyxFQUFFO2dCQUN6RCxRQUFPLCtCQUErQjtZQUN4QztZ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QzpcXFVzZXJzXFxkaWxhblxcRG9jdW1lbnRzXFxHaXRIdWJcXFdlYi1TY3JhcHBpbmctRnJvbnRlbmQyXFxzcmNcXGhvb2tzXFx1c2Utc3NlLXN0cmVhbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IFNjcmFwaW5nUmVzdWx0IH0gZnJvbSAnQC9saWIvYXBpJ1xyXG5cclxuaW50ZXJmYWNlIFNTRVByb2dyZXNzIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBjb21wbGV0ZWQ6IG51bWJlclxyXG4gIHRvdGFsOiBudW1iZXJcclxuICBwZXJjZW50YWdlOiBudW1iZXJcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NFUmVzdWx0IGV4dGVuZHMgU2NyYXBpbmdSZXN1bHQge1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTU0VDb21wbGV0ZSB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nXHJcbiAgY29tcGxldGVkOiBudW1iZXJcclxuICB0b3RhbDogbnVtYmVyXHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFNTRUVycm9yIHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBlcnJvcj86IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlU1NFU3RyZWFtT3B0aW9ucyB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nIHwgbnVsbFxyXG4gIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IFNTRVByb2dyZXNzKSA9PiB2b2lkXHJcbiAgb25SZXN1bHQ/OiAocmVzdWx0OiBTU0VSZXN1bHQpID0+IHZvaWRcclxuICBvbkNvbXBsZXRlPzogKGNvbXBsZXRlOiBTU0VDb21wbGV0ZSkgPT4gdm9pZFxyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IFNTRUVycm9yKSA9PiB2b2lkXHJcbiAgYmFja2VuZFVybD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU1NFU3RyZWFtKHtcclxuICBiYXRjaElkLFxyXG4gIG9uUHJvZ3Jlc3MsXHJcbiAgb25SZXN1bHQsXHJcbiAgb25Db21wbGV0ZSxcclxuICBvbkVycm9yLFxyXG4gIGJhY2tlbmRVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS92MScgLy8gQ29ubmVjdCBESVJFQ1RMWSB0byBiYWNrZW5kIGZvciBTU0UgKHByb3h5IGRvZXNuJ3Qgd29yaylcclxufTogVXNlU1NFU3RyZWFtT3B0aW9ucykge1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGV2ZW50U291cmNlUmVmID0gdXNlUmVmPEV2ZW50U291cmNlIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWxSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGhhc0NvbXBsZXRlZFJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCBpc0Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpIC8vIFByZXZlbnQgbXVsdGlwbGUgY29ubmVjdGlvbnNcclxuICBcclxuICAvLyBTdGFibGUgcmVmcyBmb3IgY2FsbGJhY2tzIHRvIGF2b2lkIHJlY29ubmVjdGlvbiBsb29wc1xyXG4gIGNvbnN0IG9uUHJvZ3Jlc3NSZWYgPSB1c2VSZWYob25Qcm9ncmVzcylcclxuICBjb25zdCBvblJlc3VsdFJlZiA9IHVzZVJlZihvblJlc3VsdClcclxuICBjb25zdCBvbkNvbXBsZXRlUmVmID0gdXNlUmVmKG9uQ29tcGxldGUpXHJcbiAgY29uc3Qgb25FcnJvclJlZiA9IHVzZVJlZihvbkVycm9yKVxyXG4gIFxyXG4gIC8vIFVwZGF0ZSByZWZzIHdoZW4gY2FsbGJhY2tzIGNoYW5nZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQgPSBvblByb2dyZXNzXHJcbiAgICBvblJlc3VsdFJlZi5jdXJyZW50ID0gb25SZXN1bHRcclxuICAgIG9uQ29tcGxldGVSZWYuY3VycmVudCA9IG9uQ29tcGxldGVcclxuICAgIG9uRXJyb3JSZWYuY3VycmVudCA9IG9uRXJyb3JcclxuICB9LCBbb25Qcm9ncmVzcywgb25SZXN1bHQsIG9uQ29tcGxldGUsIG9uRXJyb3JdKVxyXG5cclxuICAvLyBQb2xsaW5nIGZhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgY29uc3Qgc3RhcnRQb2xsaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50IHx8IGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVybiAvLyBBbHJlYWR5IHBvbGxpbmcgb3IgY29tcGxldGVkXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/CflIQgU3RhcnRpbmcgcG9sbGluZyBmYWxsYmFjayAoZXZlcnkgMiBzZWNvbmRzKScpXHJcbiAgICBcclxuICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoIWJhdGNoSWQgfHwgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdG9wUG9sbGluZygpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92MS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9YClcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUG9sbGluZyB1cGRhdGU6JywgZGF0YS5wcm9ncmVzcylcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3NcclxuICAgICAgICBpZiAob25Qcm9ncmVzc1JlZi5jdXJyZW50ICYmIGRhdGEucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgIGJhdGNoSWQ6IGRhdGEuYmF0Y2hJZCxcclxuICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzLmNvbXBsZXRlZCxcclxuICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3MudG90YWwsXHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IGRhdGEucHJvZ3Jlc3MucGVyY2VudGFnZSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBjb21wbGV0ZWRcclxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEJhdGNoIGNvbXBsZXRlZCAoZGV0ZWN0ZWQgdmlhIHBvbGxpbmcpJylcclxuICAgICAgICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAob25Db21wbGV0ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogZGF0YS5wcm9ncmVzcz8uY29tcGxldGVkIHx8IDAsXHJcbiAgICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3M/LnRvdGFsIHx8IDAsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0JhdGNoIHByb2Nlc3NpbmcgY29tcGxldGVkJyxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzdG9wUG9sbGluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUG9sbGluZyBlcnJvcjonLCBlcnIpXHJcbiAgICAgIH1cclxuICAgIH0sIDIwMDApIC8vIFBvbGwgZXZlcnkgMiBzZWNvbmRzXHJcbiAgfSwgW2JhdGNoSWRdKVxyXG5cclxuICBjb25zdCBzdG9wUG9sbGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4o+577iPIFN0b3BwaW5nIHBvbGxpbmcnKVxyXG4gICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50KVxyXG4gICAgICBwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmICghYmF0Y2hJZCB8fCBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIFNraXBwaW5nIGNvbm5lY3Rpb24gLSBiYXRjaElkOicsIGJhdGNoSWQsICdjb25uZWN0aW5nOicsIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50LCAnY29tcGxldGVkOicsIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IHRydWVcclxuICAgIGNvbnNvbGUubG9nKCfwn5SMIENvbm5lY3RpbmcgdG8gU1NFIHN0cmVhbSBmb3IgYmF0Y2g6JywgYmF0Y2hJZClcclxuICAgIGNvbnNvbGUubG9nKCfwn5OhIEJhY2tlbmQgVVJMOicsIGJhY2tlbmRVcmwpXHJcbiAgICBcclxuICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgYmF0Y2ggaXMgYWxyZWFkeSBjb21wbGV0ZVxyXG4gICAgZmV0Y2goYC9hcGkvdjEvc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfWApXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxyXG4gICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBCYXRjaCBzdGF0dXM6JywgZGF0YS5zdGF0dXMpXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBCYXRjaCBhbHJlYWR5IGNvbXBsZXRlZCwgdHJpZ2dlcmluZyBvbkNvbXBsZXRlIHdpdGggcHJvZ3Jlc3M6JywgZGF0YS5wcm9ncmVzcylcclxuICAgICAgICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgaWYgd2UgaGF2ZSB0aGUgZGF0YVxyXG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3NSZWYuY3VycmVudCAmJiBkYXRhLnByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogZGF0YS5wcm9ncmVzcy5jb21wbGV0ZWQsXHJcbiAgICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3MudG90YWwsXHJcbiAgICAgICAgICAgICAgcGVyY2VudGFnZTogZGF0YS5wcm9ncmVzcy5wZXJjZW50YWdlIHx8IDEwMCxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAob25Db21wbGV0ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogZGF0YS5wcm9ncmVzcz8uY29tcGxldGVkIHx8IDAsXHJcbiAgICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3M/LnRvdGFsIHx8IDAsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0JhdGNoIHByb2Nlc3NpbmcgYWxyZWFkeSBjb21wbGV0ZWQnLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gLy8gRG9uJ3QgY29ubmVjdCB0byBTU0UgaWYgYWxyZWFkeSBjb21wbGV0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBub3QgY29tcGxldGUsIGNvbm5lY3QgdG8gU1NFXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHVybCA9IGAke2JhY2tlbmRVcmx9L3NjcmFwaW5nLWJhdGNoLyR7YmF0Y2hJZH0vc3RyZWFtYFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflJcgU1NFIFVSTDonLCB1cmwpXHJcbiAgICAgICAgICBjb25zdCBldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSh1cmwpXHJcbiAgICAgICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50ID0gZXZlbnRTb3VyY2VcclxuXHJcbiAgICAgICAgICAvLyBDb25uZWN0ZWQgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3RlZCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNTRSBDb25uZWN0ZWQ6JywgZGF0YSlcclxuICAgICAgICAgICAgc2V0SXNDb25uZWN0ZWQodHJ1ZSlcclxuICAgICAgICAgICAgc2V0RXJyb3IobnVsbClcclxuICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBQcm9ncmVzcyBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YTogU1NFUHJvZ3Jlc3MgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFNTRSBQcm9ncmVzczonLCBkYXRhKVxyXG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KGRhdGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gUmVzdWx0IGV2ZW50IChpbmRpdmlkdWFsIGJ1c2luZXNzIHJlc3VsdClcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VsdCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IFNTRVJlc3VsdCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk6YgU1NFIFJlc3VsdDonLCByZXN1bHQpXHJcbiAgICAgICAgICAgIGlmIChvblJlc3VsdFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgb25SZXN1bHRSZWYuY3VycmVudChyZXN1bHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gQ29tcGxldGUgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IFNTRUNvbXBsZXRlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNTRSBDb21wbGV0ZTonLCBkYXRhKVxyXG4gICAgICAgICAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIG9uQ29tcGxldGVSZWYuY3VycmVudChkYXRhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBFcnJvciBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YTogU1NFRXJyb3IgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNTRSBFcnJvciBldmVudDonLCBlcnJvckRhdGEpXHJcbiAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgaWYgKG9uRXJyb3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvclJlZi5jdXJyZW50KGVycm9yRGF0YSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gR2VuZXJpYyBlcnJvciBoYW5kbGVyIHdpdGggcG9sbGluZyBmYWxsYmFja1xyXG4gICAgICAgICAgZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU1NFIENvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxyXG4gICAgICAgICAgICBzZXRFcnJvcignQ29ubmVjdGlvbiBsb3N0LiBTd2l0Y2hpbmcgdG8gcG9sbGluZy4uLicpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBjb25uZWN0aW9uIGlzIGNsb3NlZCwgZmFsbGJhY2sgdG8gcG9sbGluZ1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgU1NFIGNsb3NlZCwgc3RhcnRpbmcgcG9sbGluZyBmYWxsYmFjaycpXHJcbiAgICAgICAgICAgICAgZGlzY29ubmVjdCgpXHJcbiAgICAgICAgICAgICAgc3RhcnRQb2xsaW5nKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gY3JlYXRlIFNTRSBjb25uZWN0aW9uOicsIGVycilcclxuICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24sIHVzaW5nIHBvbGxpbmcnKVxyXG4gICAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBzdGFydFBvbGxpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBjaGVjayBiYXRjaCBzdGF0dXM6JywgZXJyKVxyXG4gICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY2hlY2sgYmF0Y2ggc3RhdHVzJylcclxuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgc3RhcnRQb2xsaW5nKCkgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiBzdGF0dXMgY2hlY2sgZmFpbHNcclxuICAgICAgfSlcclxuICB9LCBbYmF0Y2hJZCwgYmFja2VuZFVybCwgc3RhcnRQb2xsaW5nXSlcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIERpc2Nvbm5lY3RpbmcgU1NFIHN0cmVhbScpXHJcbiAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcclxuICAgIH1cclxuICAgIHN0b3BQb2xsaW5nKClcclxuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gZmFsc2VcclxuICB9LCBbc3RvcFBvbGxpbmddKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGJhdGNoSWQpIHtcclxuICAgICAgY29ubmVjdCgpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZGlzY29ubmVjdCgpXHJcbiAgICB9XHJcbiAgICAvLyBPbmx5IHJlY29ubmVjdCB3aGVuIGJhdGNoSWQgY2hhbmdlcywgbm90IHdoZW4gY2FsbGJhY2tzIGNoYW5nZVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gIH0sIFtiYXRjaElkXSlcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzQ29ubmVjdGVkLFxyXG4gICAgZXJyb3IsXHJcbiAgICBkaXNjb25uZWN0XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlU1NFU3RyZWFtIiwiYmF0Y2hJZCIsIm9uUHJvZ3Jlc3MiLCJvblJlc3VsdCIsIm9uQ29tcGxldGUiLCJvbkVycm9yIiwiYmFja2VuZFVybCIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJlcnJvciIsInNldEVycm9yIiwiZXZlbnRTb3VyY2VSZWYiLCJwb2xsaW5nSW50ZXJ2YWxSZWYiLCJoYXNDb21wbGV0ZWRSZWYiLCJpc0Nvbm5lY3RpbmdSZWYiLCJvblByb2dyZXNzUmVmIiwib25SZXN1bHRSZWYiLCJvbkNvbXBsZXRlUmVmIiwib25FcnJvclJlZiIsImN1cnJlbnQiLCJzdGFydFBvbGxpbmciLCJjb25zb2xlIiwibG9nIiwic2V0SW50ZXJ2YWwiLCJzdG9wUG9sbGluZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsInByb2dyZXNzIiwiY29tcGxldGVkIiwidG90YWwiLCJwZXJjZW50YWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3RhdHVzIiwibWVzc2FnZSIsImVyciIsImNsZWFySW50ZXJ2YWwiLCJjb25uZWN0IiwidGhlbiIsInJlcyIsInVybCIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJKU09OIiwicGFyc2UiLCJyZXN1bHQiLCJkaXNjb25uZWN0IiwiZXJyb3JEYXRhIiwib25lcnJvciIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJjYXRjaCIsImNsb3NlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-sse-stream.ts\n"));

/***/ })

});