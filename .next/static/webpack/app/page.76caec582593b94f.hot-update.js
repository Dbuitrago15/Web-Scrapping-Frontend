"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-sse-stream.ts":
/*!*************************************!*\
  !*** ./src/hooks/use-sse-stream.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSEStream: () => (/* binding */ useSSEStream)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useSSEStream(param) {\n    let { batchId, onProgress, onResult, onComplete, onError, backendUrl = 'http://localhost:3000/api/v1' // Connect DIRECTLY to backend for SSE (proxy doesn't work)\n     } = param;\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hasCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false) // Prevent multiple connections\n    ;\n    // Stable refs for callbacks to avoid reconnection loops\n    const onProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onProgress);\n    const onResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onResult);\n    const onCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onComplete);\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            onProgressRef.current = onProgress;\n            onResultRef.current = onResult;\n            onCompleteRef.current = onComplete;\n            onErrorRef.current = onError;\n        }\n    }[\"useSSEStream.useEffect\"], [\n        onProgress,\n        onResult,\n        onComplete,\n        onError\n    ]);\n    // Polling fallback function\n    const startPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[startPolling]\": ()=>{\n            if (pollingIntervalRef.current || hasCompletedRef.current) {\n                return; // Already polling or completed\n            }\n            console.log('ðŸ”„ Starting polling fallback (every 2 seconds)');\n            pollingIntervalRef.current = setInterval({\n                \"useSSEStream.useCallback[startPolling]\": async ()=>{\n                    if (!batchId || hasCompletedRef.current) {\n                        stopPolling();\n                        return;\n                    }\n                    try {\n                        const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId));\n                        const data = await response.json();\n                        console.log('ðŸ“Š Polling update:', data.progress);\n                        // Update progress\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        // Check if completed\n                        if (data.status === 'completed') {\n                            console.log('âœ… Batch completed (detected via polling)');\n                            hasCompletedRef.current = true;\n                            if (onCompleteRef.current) {\n                                var _data_progress, _data_progress1;\n                                onCompleteRef.current({\n                                    batchId: data.batchId,\n                                    completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                    total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                    message: 'Batch processing completed',\n                                    timestamp: new Date().toISOString()\n                                });\n                            }\n                            stopPolling();\n                        }\n                    } catch (err) {\n                        console.error('âŒ Polling error:', err);\n                    }\n                }\n            }[\"useSSEStream.useCallback[startPolling]\"], 2000) // Poll every 2 seconds\n            ;\n        }\n    }[\"useSSEStream.useCallback[startPolling]\"], [\n        batchId\n    ]);\n    const stopPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[stopPolling]\": ()=>{\n            if (pollingIntervalRef.current) {\n                console.log('â¹ï¸ Stopping polling');\n                clearInterval(pollingIntervalRef.current);\n                pollingIntervalRef.current = null;\n            }\n        }\n    }[\"useSSEStream.useCallback[stopPolling]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[connect]\": ()=>{\n            if (!batchId || isConnectingRef.current || hasCompletedRef.current) {\n                console.log('âš ï¸ Skipping connection - batchId:', batchId, 'connecting:', isConnectingRef.current, 'completed:', hasCompletedRef.current);\n                return;\n            }\n            isConnectingRef.current = true;\n            console.log('ðŸ”Œ Connecting to SSE stream for batch:', batchId);\n            console.log('ðŸ“¡ Backend URL:', backendUrl);\n            // First, check if the batch is already complete\n            fetch(\"/api/v1/scraping-batch/\".concat(batchId)).then({\n                \"useSSEStream.useCallback[connect]\": (res)=>res.json()\n            }[\"useSSEStream.useCallback[connect]\"]).then({\n                \"useSSEStream.useCallback[connect]\": (data)=>{\n                    console.log('ðŸ“‹ Batch status:', data.status);\n                    if (data.status === 'completed') {\n                        console.log('âœ… Batch already completed, triggering onComplete with progress:', data.progress);\n                        hasCompletedRef.current = true;\n                        isConnectingRef.current = false;\n                        // Update progress immediately if we have the data\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage || 100,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        if (onCompleteRef.current) {\n                            var _data_progress, _data_progress1;\n                            onCompleteRef.current({\n                                batchId: data.batchId,\n                                completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                message: 'Batch processing already completed',\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        return; // Don't connect to SSE if already complete\n                    }\n                    // If not complete, connect to SSE\n                    try {\n                        const url = \"\".concat(backendUrl, \"/scraping-batch/\").concat(batchId, \"/stream\");\n                        console.log('ðŸ”— SSE URL:', url);\n                        const eventSource = new EventSource(url);\n                        eventSourceRef.current = eventSource;\n                        // Connected event\n                        eventSource.addEventListener('connected', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('âœ… SSE Connected:', data);\n                                setIsConnected(true);\n                                setError(null);\n                                isConnectingRef.current = false;\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Progress event\n                        eventSource.addEventListener('progress', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('ðŸ“Š Progress data received:', data);\n                                // Only log progress updates, not every 2-second ping\n                                if (onProgressRef.current) {\n                                    onProgressRef.current(data);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Result event (individual business result)\n                        eventSource.addEventListener('result', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                var _result_originalData;\n                                const result = JSON.parse(event.data);\n                                console.log('ðŸ“¦ Result received:', (_result_originalData = result.originalData) === null || _result_originalData === void 0 ? void 0 : _result_originalData.name, \"(\".concat(result.index + 1, \")\"));\n                                // Don't log every result (backend sends duplicates on each progress event)\n                                if (onResultRef.current) {\n                                    onResultRef.current(result);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Complete event\n                        eventSource.addEventListener('complete', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('âœ… SSE Complete:', data);\n                                hasCompletedRef.current = true;\n                                if (onCompleteRef.current) {\n                                    onCompleteRef.current(data);\n                                }\n                                disconnect();\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Error event\n                        eventSource.addEventListener('error', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                if (event.data) {\n                                    const errorData = JSON.parse(event.data);\n                                    console.error('âŒ SSE Error event:', errorData);\n                                    setError(errorData.message);\n                                    if (onErrorRef.current) {\n                                        onErrorRef.current(errorData);\n                                    }\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Generic error handler with polling fallback\n                        eventSource.onerror = ({\n                            \"useSSEStream.useCallback[connect]\": (error)=>{\n                                console.error('âŒ SSE Connection error:', error);\n                                setIsConnected(false);\n                                setError('Connection lost. Switching to polling...');\n                                // If connection is closed, fallback to polling\n                                if (eventSource.readyState === EventSource.CLOSED) {\n                                    console.log('ðŸ”„ SSE closed, starting polling fallback');\n                                    disconnect();\n                                    startPolling();\n                                }\n                            }\n                        })[\"useSSEStream.useCallback[connect]\"];\n                    } catch (err) {\n                        console.error('âŒ Failed to create SSE connection:', err);\n                        setError('Failed to establish connection, using polling');\n                        setIsConnected(false);\n                        isConnectingRef.current = false;\n                        startPolling();\n                    }\n                }\n            }[\"useSSEStream.useCallback[connect]\"]).catch({\n                \"useSSEStream.useCallback[connect]\": (err)=>{\n                    console.error('âŒ Failed to check batch status:', err);\n                    setError('Failed to check batch status');\n                    isConnectingRef.current = false;\n                    startPolling() // Fallback to polling if status check fails\n                    ;\n                }\n            }[\"useSSEStream.useCallback[connect]\"]);\n        }\n    }[\"useSSEStream.useCallback[connect]\"], [\n        batchId,\n        backendUrl,\n        startPolling\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[disconnect]\": ()=>{\n            if (eventSourceRef.current) {\n                console.log('ðŸ”Œ Disconnecting SSE stream');\n                eventSourceRef.current.close();\n                eventSourceRef.current = null;\n                setIsConnected(false);\n            }\n            stopPolling();\n            isConnectingRef.current = false;\n            hasCompletedRef.current = false;\n        }\n    }[\"useSSEStream.useCallback[disconnect]\"], [\n        stopPolling\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            if (batchId) {\n                connect();\n            }\n            return ({\n                \"useSSEStream.useEffect\": ()=>{\n                    // Only disconnect when unmounting or batchId actually changes\n                    if (eventSourceRef.current) {\n                        console.log('ðŸ”Œ Cleanup: Disconnecting SSE stream');\n                        eventSourceRef.current.close();\n                        eventSourceRef.current = null;\n                    }\n                    if (pollingIntervalRef.current) {\n                        clearInterval(pollingIntervalRef.current);\n                        pollingIntervalRef.current = null;\n                    }\n                }\n            })[\"useSSEStream.useEffect\"];\n        // Only reconnect when batchId changes, not when callbacks change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSSEStream.useEffect\"], [\n        batchId\n    ]);\n    return {\n        isConnected,\n        error,\n        disconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utc3NlLXN0cmVhbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0U7QUFxQ3pELFNBQVNJLGFBQWEsS0FPUDtRQVBPLEVBQzNCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsYUFBYSwrQkFBK0IsMkRBQTJEO0lBQTVELEVBQ3ZCLEdBUE87SUFRM0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTWEsaUJBQWlCZCw2Q0FBTUEsQ0FBcUI7SUFDbEQsTUFBTWUscUJBQXFCZiw2Q0FBTUEsQ0FBd0I7SUFDekQsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBQyxPQUFPLCtCQUErQjs7SUFFckUsd0RBQXdEO0lBQ3hELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBQ0s7SUFDN0IsTUFBTWMsY0FBY25CLDZDQUFNQSxDQUFDTTtJQUMzQixNQUFNYyxnQkFBZ0JwQiw2Q0FBTUEsQ0FBQ087SUFDN0IsTUFBTWMsYUFBYXJCLDZDQUFNQSxDQUFDUTtJQUUxQixvQ0FBb0M7SUFDcENULGdEQUFTQTtrQ0FBQztZQUNSbUIsY0FBY0ksT0FBTyxHQUFHakI7WUFDeEJjLFlBQVlHLE9BQU8sR0FBR2hCO1lBQ3RCYyxjQUFjRSxPQUFPLEdBQUdmO1lBQ3hCYyxXQUFXQyxPQUFPLEdBQUdkO1FBQ3ZCO2lDQUFHO1FBQUNIO1FBQVlDO1FBQVVDO1FBQVlDO0tBQVE7SUFFOUMsNEJBQTRCO0lBQzVCLE1BQU1lLGVBQWVyQixrREFBV0E7a0RBQUM7WUFDL0IsSUFBSWEsbUJBQW1CTyxPQUFPLElBQUlOLGdCQUFnQk0sT0FBTyxFQUFFO2dCQUN6RCxRQUFPLCtCQUErQjtZQUN4QztZ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Q0FBTztvQkFDTCw4REFBOEQ7b0JBQzlELElBQUk3QixlQUFlUSxPQUFPLEVBQUU7d0JBQzFCRSxRQUFRQyxHQUFHLENBQUM7d0JBQ1pYLGVBQWVRLE9BQU8sQ0FBQ3lDLEtBQUs7d0JBQzVCakQsZUFBZVEsT0FBTyxHQUFHO29CQUMzQjtvQkFDQSxJQUFJUCxtQkFBbUJPLE9BQU8sRUFBRTt3QkFDOUJvQixjQUFjM0IsbUJBQW1CTyxPQUFPO3dCQUN4Q1AsbUJBQW1CTyxPQUFPLEdBQUc7b0JBQy9CO2dCQUNGOztRQUNBLGlFQUFpRTtRQUNqRSx1REFBdUQ7UUFDekQ7aUNBQUc7UUFBQ2xCO0tBQVE7SUFFWixPQUFPO1FBQ0xNO1FBQ0FFO1FBQ0E2QztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZGlsYW5cXERvY3VtZW50c1xcR2l0SHViXFxXZWItU2NyYXBwaW5nLUZyb250ZW5kMlxcc3JjXFxob29rc1xcdXNlLXNzZS1zdHJlYW0udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBTY3JhcGluZ1Jlc3VsdCB9IGZyb20gJ0AvbGliL2FwaSdcclxuXHJcbmludGVyZmFjZSBTU0VQcm9ncmVzcyB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nXHJcbiAgY29tcGxldGVkOiBudW1iZXJcclxuICB0b3RhbDogbnVtYmVyXHJcbiAgcGVyY2VudGFnZTogbnVtYmVyXHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFNTRVJlc3VsdCBleHRlbmRzIFNjcmFwaW5nUmVzdWx0IHtcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NFQ29tcGxldGUge1xyXG4gIGJhdGNoSWQ6IHN0cmluZ1xyXG4gIGNvbXBsZXRlZDogbnVtYmVyXHJcbiAgdG90YWw6IG51bWJlclxyXG4gIG1lc3NhZ2U6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTU0VFcnJvciB7XHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgZXJyb3I/OiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZVNTRVN0cmVhbU9wdGlvbnMge1xyXG4gIGJhdGNoSWQ6IHN0cmluZyB8IG51bGxcclxuICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBTU0VQcm9ncmVzcykgPT4gdm9pZFxyXG4gIG9uUmVzdWx0PzogKHJlc3VsdDogU1NFUmVzdWx0KSA9PiB2b2lkXHJcbiAgb25Db21wbGV0ZT86IChjb21wbGV0ZTogU1NFQ29tcGxldGUpID0+IHZvaWRcclxuICBvbkVycm9yPzogKGVycm9yOiBTU0VFcnJvcikgPT4gdm9pZFxyXG4gIGJhY2tlbmRVcmw/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNTRVN0cmVhbSh7XHJcbiAgYmF0Y2hJZCxcclxuICBvblByb2dyZXNzLFxyXG4gIG9uUmVzdWx0LFxyXG4gIG9uQ29tcGxldGUsXHJcbiAgb25FcnJvcixcclxuICBiYWNrZW5kVXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvdjEnIC8vIENvbm5lY3QgRElSRUNUTFkgdG8gYmFja2VuZCBmb3IgU1NFIChwcm94eSBkb2Vzbid0IHdvcmspXHJcbn06IFVzZVNTRVN0cmVhbU9wdGlvbnMpIHtcclxuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBldmVudFNvdXJjZVJlZiA9IHVzZVJlZjxFdmVudFNvdXJjZSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgcG9sbGluZ0ludGVydmFsUmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbClcclxuICBjb25zdCBoYXNDb21wbGV0ZWRSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgaXNDb25uZWN0aW5nUmVmID0gdXNlUmVmKGZhbHNlKSAvLyBQcmV2ZW50IG11bHRpcGxlIGNvbm5lY3Rpb25zXHJcbiAgXHJcbiAgLy8gU3RhYmxlIHJlZnMgZm9yIGNhbGxiYWNrcyB0byBhdm9pZCByZWNvbm5lY3Rpb24gbG9vcHNcclxuICBjb25zdCBvblByb2dyZXNzUmVmID0gdXNlUmVmKG9uUHJvZ3Jlc3MpXHJcbiAgY29uc3Qgb25SZXN1bHRSZWYgPSB1c2VSZWYob25SZXN1bHQpXHJcbiAgY29uc3Qgb25Db21wbGV0ZVJlZiA9IHVzZVJlZihvbkNvbXBsZXRlKVxyXG4gIGNvbnN0IG9uRXJyb3JSZWYgPSB1c2VSZWYob25FcnJvcilcclxuICBcclxuICAvLyBVcGRhdGUgcmVmcyB3aGVuIGNhbGxiYWNrcyBjaGFuZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50ID0gb25Qcm9ncmVzc1xyXG4gICAgb25SZXN1bHRSZWYuY3VycmVudCA9IG9uUmVzdWx0XHJcbiAgICBvbkNvbXBsZXRlUmVmLmN1cnJlbnQgPSBvbkNvbXBsZXRlXHJcbiAgICBvbkVycm9yUmVmLmN1cnJlbnQgPSBvbkVycm9yXHJcbiAgfSwgW29uUHJvZ3Jlc3MsIG9uUmVzdWx0LCBvbkNvbXBsZXRlLCBvbkVycm9yXSlcclxuXHJcbiAgLy8gUG9sbGluZyBmYWxsYmFjayBmdW5jdGlvblxyXG4gIGNvbnN0IHN0YXJ0UG9sbGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCB8fCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICByZXR1cm4gLy8gQWxyZWFkeSBwb2xsaW5nIG9yIGNvbXBsZXRlZFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCfwn5SEIFN0YXJ0aW5nIHBvbGxpbmcgZmFsbGJhY2sgKGV2ZXJ5IDIgc2Vjb25kcyknKVxyXG4gICAgXHJcbiAgICBwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKCFiYXRjaElkIHx8IGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgc3RvcFBvbGxpbmcoKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvdjEvc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfWApXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFBvbGxpbmcgdXBkYXRlOicsIGRhdGEucHJvZ3Jlc3MpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzXHJcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3NSZWYuY3VycmVudCAmJiBkYXRhLnByb2dyZXNzKSB7XHJcbiAgICAgICAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQoe1xyXG4gICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgIGNvbXBsZXRlZDogZGF0YS5wcm9ncmVzcy5jb21wbGV0ZWQsXHJcbiAgICAgICAgICAgIHRvdGFsOiBkYXRhLnByb2dyZXNzLnRvdGFsLFxyXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBkYXRhLnByb2dyZXNzLnBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29tcGxldGVkXHJcbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnY29tcGxldGVkJykge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBCYXRjaCBjb21wbGV0ZWQgKGRldGVjdGVkIHZpYSBwb2xsaW5nKScpXHJcbiAgICAgICAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKG9uQ29tcGxldGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlUmVmLmN1cnJlbnQoe1xyXG4gICAgICAgICAgICAgIGJhdGNoSWQ6IGRhdGEuYmF0Y2hJZCxcclxuICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGRhdGEucHJvZ3Jlc3M/LmNvbXBsZXRlZCB8fCAwLFxyXG4gICAgICAgICAgICAgIHRvdGFsOiBkYXRhLnByb2dyZXNzPy50b3RhbCB8fCAwLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdCYXRjaCBwcm9jZXNzaW5nIGNvbXBsZXRlZCcsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc3RvcFBvbGxpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFBvbGxpbmcgZXJyb3I6JywgZXJyKVxyXG4gICAgICB9XHJcbiAgICB9LCAyMDAwKSAvLyBQb2xsIGV2ZXJ5IDIgc2Vjb25kc1xyXG4gIH0sIFtiYXRjaElkXSlcclxuXHJcbiAgY29uc3Qgc3RvcFBvbGxpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ+KPue+4jyBTdG9wcGluZyBwb2xsaW5nJylcclxuICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudClcclxuICAgICAgcG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcblxyXG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoIWJhdGNoSWQgfHwgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgfHwgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBTa2lwcGluZyBjb25uZWN0aW9uIC0gYmF0Y2hJZDonLCBiYXRjaElkLCAnY29ubmVjdGluZzonLCBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCwgJ2NvbXBsZXRlZDonLCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcblxyXG4gICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICBjb25zb2xlLmxvZygn8J+UjCBDb25uZWN0aW5nIHRvIFNTRSBzdHJlYW0gZm9yIGJhdGNoOicsIGJhdGNoSWQpXHJcbiAgICBjb25zb2xlLmxvZygn8J+ToSBCYWNrZW5kIFVSTDonLCBiYWNrZW5kVXJsKVxyXG4gICAgXHJcbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGJhdGNoIGlzIGFscmVhZHkgY29tcGxldGVcclxuICAgIGZldGNoKGAvYXBpL3YxL3NjcmFwaW5nLWJhdGNoLyR7YmF0Y2hJZH1gKVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcclxuICAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgQmF0Y2ggc3RhdHVzOicsIGRhdGEuc3RhdHVzKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQmF0Y2ggYWxyZWFkeSBjb21wbGV0ZWQsIHRyaWdnZXJpbmcgb25Db21wbGV0ZSB3aXRoIHByb2dyZXNzOicsIGRhdGEucHJvZ3Jlc3MpXHJcbiAgICAgICAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IGlmIHdlIGhhdmUgdGhlIGRhdGFcclxuICAgICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQgJiYgZGF0YS5wcm9ncmVzcykge1xyXG4gICAgICAgICAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQoe1xyXG4gICAgICAgICAgICAgIGJhdGNoSWQ6IGRhdGEuYmF0Y2hJZCxcclxuICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGRhdGEucHJvZ3Jlc3MuY29tcGxldGVkLFxyXG4gICAgICAgICAgICAgIHRvdGFsOiBkYXRhLnByb2dyZXNzLnRvdGFsLFxyXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IGRhdGEucHJvZ3Jlc3MucGVyY2VudGFnZSB8fCAxMDAsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKG9uQ29tcGxldGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlUmVmLmN1cnJlbnQoe1xyXG4gICAgICAgICAgICAgIGJhdGNoSWQ6IGRhdGEuYmF0Y2hJZCxcclxuICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGRhdGEucHJvZ3Jlc3M/LmNvbXBsZXRlZCB8fCAwLFxyXG4gICAgICAgICAgICAgIHRvdGFsOiBkYXRhLnByb2dyZXNzPy50b3RhbCB8fCAwLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdCYXRjaCBwcm9jZXNzaW5nIGFscmVhZHkgY29tcGxldGVkJyxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIC8vIERvbid0IGNvbm5lY3QgdG8gU1NFIGlmIGFscmVhZHkgY29tcGxldGVcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgbm90IGNvbXBsZXRlLCBjb25uZWN0IHRvIFNTRVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB1cmwgPSBgJHtiYWNrZW5kVXJsfS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9L3N0cmVhbWBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SXIFNTRSBVUkw6JywgdXJsKVxyXG4gICAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UodXJsKVxyXG4gICAgICAgICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudCA9IGV2ZW50U291cmNlXHJcblxyXG4gICAgICAgICAgLy8gQ29ubmVjdGVkIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0ZWQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTU0UgQ29ubmVjdGVkOicsIGRhdGEpXHJcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXHJcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpXHJcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gUHJvZ3Jlc3MgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IFNTRVByb2dyZXNzID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBQcm9ncmVzcyBkYXRhIHJlY2VpdmVkOicsIGRhdGEpXHJcbiAgICAgICAgICAgIC8vIE9ubHkgbG9nIHByb2dyZXNzIHVwZGF0ZXMsIG5vdCBldmVyeSAyLXNlY29uZCBwaW5nXHJcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQoZGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBSZXN1bHQgZXZlbnQgKGluZGl2aWR1YWwgYnVzaW5lc3MgcmVzdWx0KVxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncmVzdWx0JywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogU1NFUmVzdWx0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBSZXN1bHQgcmVjZWl2ZWQ6JywgcmVzdWx0Lm9yaWdpbmFsRGF0YT8ubmFtZSwgYCgke3Jlc3VsdC5pbmRleCArIDF9KWApXHJcbiAgICAgICAgICAgIC8vIERvbid0IGxvZyBldmVyeSByZXN1bHQgKGJhY2tlbmQgc2VuZHMgZHVwbGljYXRlcyBvbiBlYWNoIHByb2dyZXNzIGV2ZW50KVxyXG4gICAgICAgICAgICBpZiAob25SZXN1bHRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIG9uUmVzdWx0UmVmLmN1cnJlbnQocmVzdWx0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIENvbXBsZXRlIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBTU0VDb21wbGV0ZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTU0UgQ29tcGxldGU6JywgZGF0YSlcclxuICAgICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvbkNvbXBsZXRlUmVmLmN1cnJlbnQoZGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXNjb25uZWN0KClcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gRXJyb3IgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGE6IFNTRUVycm9yID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTU0UgRXJyb3IgZXZlbnQ6JywgZXJyb3JEYXRhKVxyXG4gICAgICAgICAgICAgIHNldEVycm9yKGVycm9yRGF0YS5tZXNzYWdlKVxyXG4gICAgICAgICAgICAgIGlmIChvbkVycm9yUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3JSZWYuY3VycmVudChlcnJvckRhdGEpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIEdlbmVyaWMgZXJyb3IgaGFuZGxlciB3aXRoIHBvbGxpbmcgZmFsbGJhY2tcclxuICAgICAgICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNTRSBDb25uZWN0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcclxuICAgICAgICAgICAgc2V0RXJyb3IoJ0Nvbm5lY3Rpb24gbG9zdC4gU3dpdGNoaW5nIHRvIHBvbGxpbmcuLi4nKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBpcyBjbG9zZWQsIGZhbGxiYWNrIHRvIHBvbGxpbmdcclxuICAgICAgICAgICAgaWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFNTRSBjbG9zZWQsIHN0YXJ0aW5nIHBvbGxpbmcgZmFsbGJhY2snKVxyXG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgICAgIHN0YXJ0UG9sbGluZygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNyZWF0ZSBTU0UgY29ubmVjdGlvbjonLCBlcnIpXHJcbiAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGVzdGFibGlzaCBjb25uZWN0aW9uLCB1c2luZyBwb2xsaW5nJylcclxuICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxyXG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgc3RhcnRQb2xsaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gY2hlY2sgYmF0Y2ggc3RhdHVzOicsIGVycilcclxuICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGNoZWNrIGJhdGNoIHN0YXR1cycpXHJcbiAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgIHN0YXJ0UG9sbGluZygpIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgc3RhdHVzIGNoZWNrIGZhaWxzXHJcbiAgICAgIH0pXHJcbiAgfSwgW2JhdGNoSWQsIGJhY2tlbmRVcmwsIHN0YXJ0UG9sbGluZ10pXHJcblxyXG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoZXZlbnRTb3VyY2VSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjCBEaXNjb25uZWN0aW5nIFNTRSBzdHJlYW0nKVxyXG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICB9XHJcbiAgICBzdG9wUG9sbGluZygpXHJcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgfSwgW3N0b3BQb2xsaW5nXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChiYXRjaElkKSB7XHJcbiAgICAgIGNvbm5lY3QoKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIC8vIE9ubHkgZGlzY29ubmVjdCB3aGVuIHVubW91bnRpbmcgb3IgYmF0Y2hJZCBhY3R1YWxseSBjaGFuZ2VzXHJcbiAgICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIwgQ2xlYW51cDogRGlzY29ubmVjdGluZyBTU0Ugc3RyZWFtJylcclxuICAgICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgcG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE9ubHkgcmVjb25uZWN0IHdoZW4gYmF0Y2hJZCBjaGFuZ2VzLCBub3Qgd2hlbiBjYWxsYmFja3MgY2hhbmdlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW2JhdGNoSWRdKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXNDb25uZWN0ZWQsXHJcbiAgICBlcnJvcixcclxuICAgIGRpc2Nvbm5lY3RcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTU0VTdHJlYW0iLCJiYXRjaElkIiwib25Qcm9ncmVzcyIsIm9uUmVzdWx0Iiwib25Db21wbGV0ZSIsIm9uRXJyb3IiLCJiYWNrZW5kVXJsIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImVycm9yIiwic2V0RXJyb3IiLCJldmVudFNvdXJjZVJlZiIsInBvbGxpbmdJbnRlcnZhbFJlZiIsImhhc0NvbXBsZXRlZFJlZiIsImlzQ29ubmVjdGluZ1JlZiIsIm9uUHJvZ3Jlc3NSZWYiLCJvblJlc3VsdFJlZiIsIm9uQ29tcGxldGVSZWYiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInN0YXJ0UG9sbGluZyIsImNvbnNvbGUiLCJsb2ciLCJzZXRJbnRlcnZhbCIsInN0b3BQb2xsaW5nIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWQiLCJ0b3RhbCIsInBlcmNlbnRhZ2UiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzdGF0dXMiLCJtZXNzYWdlIiwiZXJyIiwiY2xlYXJJbnRlcnZhbCIsImNvbm5lY3QiLCJ0aGVuIiwicmVzIiwidXJsIiwiZXZlbnRTb3VyY2UiLCJFdmVudFNvdXJjZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIkpTT04iLCJwYXJzZSIsInJlc3VsdCIsIm9yaWdpbmFsRGF0YSIsIm5hbWUiLCJpbmRleCIsImRpc2Nvbm5lY3QiLCJlcnJvckRhdGEiLCJvbmVycm9yIiwicmVhZHlTdGF0ZSIsIkNMT1NFRCIsImNhdGNoIiwiY2xvc2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-sse-stream.ts\n"));

/***/ })

});