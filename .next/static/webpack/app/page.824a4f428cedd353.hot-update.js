"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-sse-stream.ts":
/*!*************************************!*\
  !*** ./src/hooks/use-sse-stream.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSEStream: () => (/* binding */ useSSEStream)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useSSEStream(param) {\n    let { batchId, onProgress, onResult, onComplete, onError, backendUrl = '/api/v1' // Use Next.js proxy for SSE\n     } = param;\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hasCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false) // Prevent multiple connections\n    ;\n    // Stable refs for callbacks to avoid reconnection loops\n    const onProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onProgress);\n    const onResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onResult);\n    const onCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onComplete);\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            onProgressRef.current = onProgress;\n            onResultRef.current = onResult;\n            onCompleteRef.current = onComplete;\n            onErrorRef.current = onError;\n        }\n    }[\"useSSEStream.useEffect\"], [\n        onProgress,\n        onResult,\n        onComplete,\n        onError\n    ]);\n    // Polling fallback function\n    const startPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[startPolling]\": ()=>{\n            if (pollingIntervalRef.current || hasCompletedRef.current) {\n                return; // Already polling or completed\n            }\n            console.log('🔄 Starting polling fallback (every 2 seconds)');\n            pollingIntervalRef.current = setInterval({\n                \"useSSEStream.useCallback[startPolling]\": async ()=>{\n                    if (!batchId || hasCompletedRef.current) {\n                        stopPolling();\n                        return;\n                    }\n                    try {\n                        const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId));\n                        const data = await response.json();\n                        console.log('📊 Polling update:', data.progress);\n                        // Update progress\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        // Check if completed\n                        if (data.status === 'completed') {\n                            console.log('✅ Batch completed (detected via polling)');\n                            hasCompletedRef.current = true;\n                            if (onCompleteRef.current) {\n                                var _data_progress, _data_progress1;\n                                onCompleteRef.current({\n                                    batchId: data.batchId,\n                                    completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                    total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                    message: 'Batch processing completed',\n                                    timestamp: new Date().toISOString()\n                                });\n                            }\n                            stopPolling();\n                        }\n                    } catch (err) {\n                        console.error('❌ Polling error:', err);\n                    }\n                }\n            }[\"useSSEStream.useCallback[startPolling]\"], 2000) // Poll every 2 seconds\n            ;\n        }\n    }[\"useSSEStream.useCallback[startPolling]\"], [\n        batchId\n    ]);\n    const stopPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[stopPolling]\": ()=>{\n            if (pollingIntervalRef.current) {\n                console.log('⏹️ Stopping polling');\n                clearInterval(pollingIntervalRef.current);\n                pollingIntervalRef.current = null;\n            }\n        }\n    }[\"useSSEStream.useCallback[stopPolling]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[connect]\": ()=>{\n            if (!batchId || isConnectingRef.current || hasCompletedRef.current) {\n                console.log('⚠️ Skipping connection - batchId:', batchId, 'connecting:', isConnectingRef.current, 'completed:', hasCompletedRef.current);\n                return;\n            }\n            isConnectingRef.current = true;\n            console.log('🔌 Connecting to SSE stream for batch:', batchId);\n            console.log('📡 Backend URL:', backendUrl);\n            // First, check if the batch is already complete\n            fetch(\"/api/v1/scraping-batch/\".concat(batchId)).then({\n                \"useSSEStream.useCallback[connect]\": (res)=>res.json()\n            }[\"useSSEStream.useCallback[connect]\"]).then({\n                \"useSSEStream.useCallback[connect]\": (data)=>{\n                    console.log('📋 Batch status:', data.status);\n                    if (data.status === 'completed') {\n                        console.log('✅ Batch already completed, triggering onComplete with progress:', data.progress);\n                        hasCompletedRef.current = true;\n                        isConnectingRef.current = false;\n                        // Update progress immediately if we have the data\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage || 100,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        if (onCompleteRef.current) {\n                            var _data_progress, _data_progress1;\n                            onCompleteRef.current({\n                                batchId: data.batchId,\n                                completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                message: 'Batch processing already completed',\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        return; // Don't connect to SSE if already complete\n                    }\n                    // If not complete, connect to SSE\n                    try {\n                        const url = \"\".concat(backendUrl, \"/scraping-batch/\").concat(batchId, \"/stream\");\n                        console.log('🔗 SSE URL:', url);\n                        const eventSource = new EventSource(url);\n                        eventSourceRef.current = eventSource;\n                        // Connected event\n                        eventSource.addEventListener('connected', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Connected:', data);\n                                setIsConnected(true);\n                                setError(null);\n                                isConnectingRef.current = false;\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Progress event\n                        eventSource.addEventListener('progress', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('📊 SSE Progress:', data);\n                                if (onProgressRef.current) {\n                                    onProgressRef.current(data);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Result event (individual business result)\n                        eventSource.addEventListener('result', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const result = JSON.parse(event.data);\n                                console.log('📦 SSE Result:', result);\n                                if (onResultRef.current) {\n                                    onResultRef.current(result);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Complete event\n                        eventSource.addEventListener('complete', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Complete:', data);\n                                hasCompletedRef.current = true;\n                                if (onCompleteRef.current) {\n                                    onCompleteRef.current(data);\n                                }\n                                disconnect();\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Error event\n                        eventSource.addEventListener('error', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                if (event.data) {\n                                    const errorData = JSON.parse(event.data);\n                                    console.error('❌ SSE Error event:', errorData);\n                                    setError(errorData.message);\n                                    if (onErrorRef.current) {\n                                        onErrorRef.current(errorData);\n                                    }\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Generic error handler with polling fallback\n                        eventSource.onerror = ({\n                            \"useSSEStream.useCallback[connect]\": (error)=>{\n                                console.error('❌ SSE Connection error:', error);\n                                setIsConnected(false);\n                                setError('Connection lost. Switching to polling...');\n                                // If connection is closed, fallback to polling\n                                if (eventSource.readyState === EventSource.CLOSED) {\n                                    console.log('🔄 SSE closed, starting polling fallback');\n                                    disconnect();\n                                    startPolling();\n                                }\n                            }\n                        })[\"useSSEStream.useCallback[connect]\"];\n                    } catch (err) {\n                        console.error('❌ Failed to create SSE connection:', err);\n                        setError('Failed to establish connection, using polling');\n                        setIsConnected(false);\n                        isConnectingRef.current = false;\n                        startPolling();\n                    }\n                }\n            }[\"useSSEStream.useCallback[connect]\"]).catch({\n                \"useSSEStream.useCallback[connect]\": (err)=>{\n                    console.error('❌ Failed to check batch status:', err);\n                    setError('Failed to check batch status');\n                    isConnectingRef.current = false;\n                    startPolling() // Fallback to polling if status check fails\n                    ;\n                }\n            }[\"useSSEStream.useCallback[connect]\"]);\n        }\n    }[\"useSSEStream.useCallback[connect]\"], [\n        batchId,\n        backendUrl,\n        startPolling\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[disconnect]\": ()=>{\n            if (eventSourceRef.current) {\n                console.log('🔌 Disconnecting SSE stream');\n                eventSourceRef.current.close();\n                eventSourceRef.current = null;\n                setIsConnected(false);\n            }\n            stopPolling();\n            isConnectingRef.current = false;\n            hasCompletedRef.current = false;\n        }\n    }[\"useSSEStream.useCallback[disconnect]\"], [\n        stopPolling\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            if (batchId) {\n                connect();\n            }\n            return ({\n                \"useSSEStream.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useSSEStream.useEffect\"];\n        // Only reconnect when batchId changes, not when callbacks change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSSEStream.useEffect\"], [\n        batchId\n    ]);\n    return {\n        isConnected,\n        error,\n        disconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utc3NlLXN0cmVhbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0U7QUFxQ3pELFNBQVNJLGFBQWEsS0FPUDtRQVBPLEVBQzNCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsYUFBYSxVQUFVLDRCQUE0QjtJQUE3QixFQUNGLEdBUE87SUFRM0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTWEsaUJBQWlCZCw2Q0FBTUEsQ0FBcUI7SUFDbEQsTUFBTWUscUJBQXFCZiw2Q0FBTUEsQ0FBd0I7SUFDekQsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBQyxPQUFPLCtCQUErQjs7SUFFckUsd0RBQXdEO0lBQ3hELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBQ0s7SUFDN0IsTUFBTWMsY0FBY25CLDZDQUFNQSxDQUFDTTtJQUMzQixNQUFNYyxnQkFBZ0JwQiw2Q0FBTUEsQ0FBQ087SUFDN0IsTUFBTWMsYUFBYXJCLDZDQUFNQSxDQUFDUTtJQUUxQixvQ0FBb0M7SUFDcENULGdEQUFTQTtrQ0FBQztZQUNSbUIsY0FBY0ksT0FBTyxHQUFHakI7WUFDeEJjLFlBQVlHLE9BQU8sR0FBR2hCO1lBQ3RCYyxjQUFjRSxPQUFPLEdBQUdmO1lBQ3hCYyxXQUFXQyxPQUFPLEdBQUdkO1FBQ3ZCO2lDQUFHO1FBQUNIO1FBQVlDO1FBQVVDO1FBQVlDO0tBQVE7SUFFOUMsNEJBQTRCO0lBQzVCLE1BQU1lLGVBQWVyQixrREFBV0E7a0RBQUM7WUFDL0IsSUFBSWEsbUJBQW1CTyxPQUFPLElBQUlOLGdCQUFnQk0sT0FBTyxFQUFFO2dCQUN6RCxRQUFPLCtCQUErQjtZQUN4QztZQUVB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XFVzZXJzXFxkaWxhblxcRG9jdW1lbnRzXFxHaXRIdWJcXFdlYi1TY3JhcHBpbmctRnJvbnRlbmQyXFxzcmNcXGhvb2tzXFx1c2Utc3NlLXN0cmVhbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IFNjcmFwaW5nUmVzdWx0IH0gZnJvbSAnQC9saWIvYXBpJ1xyXG5cclxuaW50ZXJmYWNlIFNTRVByb2dyZXNzIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBjb21wbGV0ZWQ6IG51bWJlclxyXG4gIHRvdGFsOiBudW1iZXJcclxuICBwZXJjZW50YWdlOiBudW1iZXJcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NFUmVzdWx0IGV4dGVuZHMgU2NyYXBpbmdSZXN1bHQge1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTU0VDb21wbGV0ZSB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nXHJcbiAgY29tcGxldGVkOiBudW1iZXJcclxuICB0b3RhbDogbnVtYmVyXHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFNTRUVycm9yIHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBlcnJvcj86IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlU1NFU3RyZWFtT3B0aW9ucyB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nIHwgbnVsbFxyXG4gIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IFNTRVByb2dyZXNzKSA9PiB2b2lkXHJcbiAgb25SZXN1bHQ/OiAocmVzdWx0OiBTU0VSZXN1bHQpID0+IHZvaWRcclxuICBvbkNvbXBsZXRlPzogKGNvbXBsZXRlOiBTU0VDb21wbGV0ZSkgPT4gdm9pZFxyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IFNTRUVycm9yKSA9PiB2b2lkXHJcbiAgYmFja2VuZFVybD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU1NFU3RyZWFtKHtcclxuICBiYXRjaElkLFxyXG4gIG9uUHJvZ3Jlc3MsXHJcbiAgb25SZXN1bHQsXHJcbiAgb25Db21wbGV0ZSxcclxuICBvbkVycm9yLFxyXG4gIGJhY2tlbmRVcmwgPSAnL2FwaS92MScgLy8gVXNlIE5leHQuanMgcHJveHkgZm9yIFNTRVxyXG59OiBVc2VTU0VTdHJlYW1PcHRpb25zKSB7XHJcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgZXZlbnRTb3VyY2VSZWYgPSB1c2VSZWY8RXZlbnRTb3VyY2UgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgaGFzQ29tcGxldGVkUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IGlzQ29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSkgLy8gUHJldmVudCBtdWx0aXBsZSBjb25uZWN0aW9uc1xyXG4gIFxyXG4gIC8vIFN0YWJsZSByZWZzIGZvciBjYWxsYmFja3MgdG8gYXZvaWQgcmVjb25uZWN0aW9uIGxvb3BzXHJcbiAgY29uc3Qgb25Qcm9ncmVzc1JlZiA9IHVzZVJlZihvblByb2dyZXNzKVxyXG4gIGNvbnN0IG9uUmVzdWx0UmVmID0gdXNlUmVmKG9uUmVzdWx0KVxyXG4gIGNvbnN0IG9uQ29tcGxldGVSZWYgPSB1c2VSZWYob25Db21wbGV0ZSlcclxuICBjb25zdCBvbkVycm9yUmVmID0gdXNlUmVmKG9uRXJyb3IpXHJcbiAgXHJcbiAgLy8gVXBkYXRlIHJlZnMgd2hlbiBjYWxsYmFja3MgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudCA9IG9uUHJvZ3Jlc3NcclxuICAgIG9uUmVzdWx0UmVmLmN1cnJlbnQgPSBvblJlc3VsdFxyXG4gICAgb25Db21wbGV0ZVJlZi5jdXJyZW50ID0gb25Db21wbGV0ZVxyXG4gICAgb25FcnJvclJlZi5jdXJyZW50ID0gb25FcnJvclxyXG4gIH0sIFtvblByb2dyZXNzLCBvblJlc3VsdCwgb25Db21wbGV0ZSwgb25FcnJvcl0pXHJcblxyXG4gIC8vIFBvbGxpbmcgZmFsbGJhY2sgZnVuY3Rpb25cclxuICBjb25zdCBzdGFydFBvbGxpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgfHwgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuIC8vIEFscmVhZHkgcG9sbGluZyBvciBjb21wbGV0ZWRcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+UhCBTdGFydGluZyBwb2xsaW5nIGZhbGxiYWNrIChldmVyeSAyIHNlY29uZHMpJylcclxuICAgIFxyXG4gICAgcG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGlmICghYmF0Y2hJZCB8fCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0b3BQb2xsaW5nKClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3YxL3NjcmFwaW5nLWJhdGNoLyR7YmF0Y2hJZH1gKVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBQb2xsaW5nIHVwZGF0ZTonLCBkYXRhLnByb2dyZXNzKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzc1xyXG4gICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQgJiYgZGF0YS5wcm9ncmVzcykge1xyXG4gICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICBjb21wbGV0ZWQ6IGRhdGEucHJvZ3Jlc3MuY29tcGxldGVkLFxyXG4gICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcy50b3RhbCxcclxuICAgICAgICAgICAgcGVyY2VudGFnZTogZGF0YS5wcm9ncmVzcy5wZXJjZW50YWdlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbXBsZXRlZFxyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQmF0Y2ggY29tcGxldGVkIChkZXRlY3RlZCB2aWEgcG9sbGluZyknKVxyXG4gICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZVJlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzPy5jb21wbGV0ZWQgfHwgMCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcz8udG90YWwgfHwgMCxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQmF0Y2ggcHJvY2Vzc2luZyBjb21wbGV0ZWQnLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHN0b3BQb2xsaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBQb2xsaW5nIGVycm9yOicsIGVycilcclxuICAgICAgfVxyXG4gICAgfSwgMjAwMCkgLy8gUG9sbCBldmVyeSAyIHNlY29uZHNcclxuICB9LCBbYmF0Y2hJZF0pXHJcblxyXG4gIGNvbnN0IHN0b3BQb2xsaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfij7nvuI8gU3RvcHBpbmcgcG9sbGluZycpXHJcbiAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpXHJcbiAgICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFiYXRjaElkIHx8IGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50IHx8IGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gU2tpcHBpbmcgY29ubmVjdGlvbiAtIGJhdGNoSWQ6JywgYmF0Y2hJZCwgJ2Nvbm5lY3Rpbmc6JywgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQsICdjb21wbGV0ZWQ6JywgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgY29uc29sZS5sb2coJ/CflIwgQ29ubmVjdGluZyB0byBTU0Ugc3RyZWFtIGZvciBiYXRjaDonLCBiYXRjaElkKVxyXG4gICAgY29uc29sZS5sb2coJ/Cfk6EgQmFja2VuZCBVUkw6JywgYmFja2VuZFVybClcclxuICAgIFxyXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBiYXRjaCBpcyBhbHJlYWR5IGNvbXBsZXRlXHJcbiAgICBmZXRjaChgL2FwaS92MS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9YClcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXHJcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEJhdGNoIHN0YXR1czonLCBkYXRhLnN0YXR1cylcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEJhdGNoIGFscmVhZHkgY29tcGxldGVkLCB0cmlnZ2VyaW5nIG9uQ29tcGxldGUgd2l0aCBwcm9ncmVzczonLCBkYXRhLnByb2dyZXNzKVxyXG4gICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBpZiB3ZSBoYXZlIHRoZSBkYXRhXHJcbiAgICAgICAgICBpZiAob25Qcm9ncmVzc1JlZi5jdXJyZW50ICYmIGRhdGEucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzLmNvbXBsZXRlZCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcy50b3RhbCxcclxuICAgICAgICAgICAgICBwZXJjZW50YWdlOiBkYXRhLnByb2dyZXNzLnBlcmNlbnRhZ2UgfHwgMTAwLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZVJlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzPy5jb21wbGV0ZWQgfHwgMCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcz8udG90YWwgfHwgMCxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQmF0Y2ggcHJvY2Vzc2luZyBhbHJlYWR5IGNvbXBsZXRlZCcsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiAvLyBEb24ndCBjb25uZWN0IHRvIFNTRSBpZiBhbHJlYWR5IGNvbXBsZXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vdCBjb21wbGV0ZSwgY29ubmVjdCB0byBTU0VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgdXJsID0gYCR7YmFja2VuZFVybH0vc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfS9zdHJlYW1gXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UlyBTU0UgVVJMOicsIHVybClcclxuICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybClcclxuICAgICAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQgPSBldmVudFNvdXJjZVxyXG5cclxuICAgICAgICAgIC8vIENvbm5lY3RlZCBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGVkJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU1NFIENvbm5lY3RlZDonLCBkYXRhKVxyXG4gICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKVxyXG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIFByb2dyZXNzIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBTU0VQcm9ncmVzcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU1NFIFByb2dyZXNzOicsIGRhdGEpXHJcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQoZGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBSZXN1bHQgZXZlbnQgKGluZGl2aWR1YWwgYnVzaW5lc3MgcmVzdWx0KVxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncmVzdWx0JywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogU1NFUmVzdWx0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBTU0UgUmVzdWx0OicsIHJlc3VsdClcclxuICAgICAgICAgICAgaWYgKG9uUmVzdWx0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvblJlc3VsdFJlZi5jdXJyZW50KHJlc3VsdClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBDb21wbGV0ZSBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YTogU1NFQ29tcGxldGUgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU1NFIENvbXBsZXRlOicsIGRhdGEpXHJcbiAgICAgICAgICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgb25Db21wbGV0ZVJlZi5jdXJyZW50KGRhdGEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzY29ubmVjdCgpXHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIEVycm9yIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhOiBTU0VFcnJvciA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU1NFIEVycm9yIGV2ZW50OicsIGVycm9yRGF0YSlcclxuICAgICAgICAgICAgICBzZXRFcnJvcihlcnJvckRhdGEubWVzc2FnZSlcclxuICAgICAgICAgICAgICBpZiAob25FcnJvclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yUmVmLmN1cnJlbnQoZXJyb3JEYXRhKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBHZW5lcmljIGVycm9yIGhhbmRsZXIgd2l0aCBwb2xsaW5nIGZhbGxiYWNrXHJcbiAgICAgICAgICBldmVudFNvdXJjZS5vbmVycm9yID0gKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTU0UgQ29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgICAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICAgICAgICAgIHNldEVycm9yKCdDb25uZWN0aW9uIGxvc3QuIFN3aXRjaGluZyB0byBwb2xsaW5nLi4uJylcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIGNvbm5lY3Rpb24gaXMgY2xvc2VkLCBmYWxsYmFjayB0byBwb2xsaW5nXHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZS5yZWFkeVN0YXRlID09PSBFdmVudFNvdXJjZS5DTE9TRUQpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBTU0UgY2xvc2VkLCBzdGFydGluZyBwb2xsaW5nIGZhbGxiYWNrJylcclxuICAgICAgICAgICAgICBkaXNjb25uZWN0KClcclxuICAgICAgICAgICAgICBzdGFydFBvbGxpbmcoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBjcmVhdGUgU1NFIGNvbm5lY3Rpb246JywgZXJyKVxyXG4gICAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBlc3RhYmxpc2ggY29ubmVjdGlvbiwgdXNpbmcgcG9sbGluZycpXHJcbiAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcclxuICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAgIHN0YXJ0UG9sbGluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNoZWNrIGJhdGNoIHN0YXR1czonLCBlcnIpXHJcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBiYXRjaCBzdGF0dXMnKVxyXG4gICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICBzdGFydFBvbGxpbmcoKSAvLyBGYWxsYmFjayB0byBwb2xsaW5nIGlmIHN0YXR1cyBjaGVjayBmYWlsc1xyXG4gICAgICB9KVxyXG4gIH0sIFtiYXRjaElkLCBiYWNrZW5kVXJsLCBzdGFydFBvbGxpbmddKVxyXG5cclxuICBjb25zdCBkaXNjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGV2ZW50U291cmNlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflIwgRGlzY29ubmVjdGluZyBTU0Ugc3RyZWFtJylcclxuICAgICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudC5jbG9zZSgpXHJcbiAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxyXG4gICAgfVxyXG4gICAgc3RvcFBvbGxpbmcoKVxyXG4gICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gIH0sIFtzdG9wUG9sbGluZ10pXHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoYmF0Y2hJZCkge1xyXG4gICAgICBjb25uZWN0KClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkaXNjb25uZWN0KClcclxuICAgIH1cclxuICAgIC8vIE9ubHkgcmVjb25uZWN0IHdoZW4gYmF0Y2hJZCBjaGFuZ2VzLCBub3Qgd2hlbiBjYWxsYmFja3MgY2hhbmdlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW2JhdGNoSWRdKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXNDb25uZWN0ZWQsXHJcbiAgICBlcnJvcixcclxuICAgIGRpc2Nvbm5lY3RcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTU0VTdHJlYW0iLCJiYXRjaElkIiwib25Qcm9ncmVzcyIsIm9uUmVzdWx0Iiwib25Db21wbGV0ZSIsIm9uRXJyb3IiLCJiYWNrZW5kVXJsIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImVycm9yIiwic2V0RXJyb3IiLCJldmVudFNvdXJjZVJlZiIsInBvbGxpbmdJbnRlcnZhbFJlZiIsImhhc0NvbXBsZXRlZFJlZiIsImlzQ29ubmVjdGluZ1JlZiIsIm9uUHJvZ3Jlc3NSZWYiLCJvblJlc3VsdFJlZiIsIm9uQ29tcGxldGVSZWYiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInN0YXJ0UG9sbGluZyIsImNvbnNvbGUiLCJsb2ciLCJzZXRJbnRlcnZhbCIsInN0b3BQb2xsaW5nIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWQiLCJ0b3RhbCIsInBlcmNlbnRhZ2UiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzdGF0dXMiLCJtZXNzYWdlIiwiZXJyIiwiY2xlYXJJbnRlcnZhbCIsImNvbm5lY3QiLCJ0aGVuIiwicmVzIiwidXJsIiwiZXZlbnRTb3VyY2UiLCJFdmVudFNvdXJjZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIkpTT04iLCJwYXJzZSIsInJlc3VsdCIsImRpc2Nvbm5lY3QiLCJlcnJvckRhdGEiLCJvbmVycm9yIiwicmVhZHlTdGF0ZSIsIkNMT1NFRCIsImNhdGNoIiwiY2xvc2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-sse-stream.ts\n"));

/***/ })

});