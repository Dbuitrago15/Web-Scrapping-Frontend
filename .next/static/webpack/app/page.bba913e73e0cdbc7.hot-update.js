"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-sse-stream.ts":
/*!*************************************!*\
  !*** ./src/hooks/use-sse-stream.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSEStream: () => (/* binding */ useSSEStream)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useSSEStream(param) {\n    let { batchId, onProgress, onResult, onComplete, onError, backendUrl = 'http://localhost:3000/api/v1' // Connect DIRECTLY to backend for SSE (proxy doesn't work)\n     } = param;\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hasCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false) // Prevent multiple connections\n    ;\n    // Stable refs for callbacks to avoid reconnection loops\n    const onProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onProgress);\n    const onResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onResult);\n    const onCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onComplete);\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            onProgressRef.current = onProgress;\n            onResultRef.current = onResult;\n            onCompleteRef.current = onComplete;\n            onErrorRef.current = onError;\n        }\n    }[\"useSSEStream.useEffect\"], [\n        onProgress,\n        onResult,\n        onComplete,\n        onError\n    ]);\n    // Polling fallback function\n    const startPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[startPolling]\": ()=>{\n            if (pollingIntervalRef.current || hasCompletedRef.current) {\n                return; // Already polling or completed\n            }\n            console.log('🔄 Starting polling fallback (every 2 seconds)');\n            pollingIntervalRef.current = setInterval({\n                \"useSSEStream.useCallback[startPolling]\": async ()=>{\n                    if (!batchId || hasCompletedRef.current) {\n                        stopPolling();\n                        return;\n                    }\n                    try {\n                        const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId));\n                        const data = await response.json();\n                        console.log('📊 Polling update:', data.progress);\n                        // Update progress\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        // Check if completed\n                        if (data.status === 'completed') {\n                            console.log('✅ Batch completed (detected via polling)');\n                            hasCompletedRef.current = true;\n                            if (onCompleteRef.current) {\n                                var _data_progress, _data_progress1;\n                                onCompleteRef.current({\n                                    batchId: data.batchId,\n                                    completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                    total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                    message: 'Batch processing completed',\n                                    timestamp: new Date().toISOString()\n                                });\n                            }\n                            stopPolling();\n                        }\n                    } catch (err) {\n                        console.error('❌ Polling error:', err);\n                    }\n                }\n            }[\"useSSEStream.useCallback[startPolling]\"], 2000) // Poll every 2 seconds\n            ;\n        }\n    }[\"useSSEStream.useCallback[startPolling]\"], [\n        batchId\n    ]);\n    const stopPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[stopPolling]\": ()=>{\n            if (pollingIntervalRef.current) {\n                console.log('⏹️ Stopping polling');\n                clearInterval(pollingIntervalRef.current);\n                pollingIntervalRef.current = null;\n            }\n        }\n    }[\"useSSEStream.useCallback[stopPolling]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[connect]\": ()=>{\n            if (!batchId || isConnectingRef.current || hasCompletedRef.current) {\n                console.log('⚠️ Skipping connection - batchId:', batchId, 'connecting:', isConnectingRef.current, 'completed:', hasCompletedRef.current);\n                return;\n            }\n            isConnectingRef.current = true;\n            console.log('🔌 Connecting to SSE stream for batch:', batchId);\n            console.log('📡 Backend URL:', backendUrl);\n            // First, check if the batch is already complete\n            fetch(\"/api/v1/scraping-batch/\".concat(batchId)).then({\n                \"useSSEStream.useCallback[connect]\": (res)=>res.json()\n            }[\"useSSEStream.useCallback[connect]\"]).then({\n                \"useSSEStream.useCallback[connect]\": (data)=>{\n                    console.log('📋 Batch status:', data.status);\n                    if (data.status === 'completed') {\n                        console.log('✅ Batch already completed, triggering onComplete with progress:', data.progress);\n                        hasCompletedRef.current = true;\n                        isConnectingRef.current = false;\n                        // Update progress immediately if we have the data\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage || 100,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        if (onCompleteRef.current) {\n                            var _data_progress, _data_progress1;\n                            onCompleteRef.current({\n                                batchId: data.batchId,\n                                completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                message: 'Batch processing already completed',\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        return; // Don't connect to SSE if already complete\n                    }\n                    // If not complete, connect to SSE\n                    try {\n                        const url = \"\".concat(backendUrl, \"/scraping-batch/\").concat(batchId, \"/stream\");\n                        console.log('🔗 SSE URL:', url);\n                        const eventSource = new EventSource(url);\n                        eventSourceRef.current = eventSource;\n                        // Connected event\n                        eventSource.addEventListener('connected', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Connected:', data);\n                                setIsConnected(true);\n                                setError(null);\n                                isConnectingRef.current = false;\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Progress event\n                        eventSource.addEventListener('progress', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                // Only log progress updates, not every 2-second ping\n                                if (onProgressRef.current) {\n                                    onProgressRef.current(data);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Result event (individual business result)\n                        eventSource.addEventListener('result', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const result = JSON.parse(event.data);\n                                // Don't log every result (backend sends duplicates on each progress event)\n                                if (onResultRef.current) {\n                                    onResultRef.current(result);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Complete event\n                        eventSource.addEventListener('complete', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Complete:', data);\n                                hasCompletedRef.current = true;\n                                if (onCompleteRef.current) {\n                                    onCompleteRef.current(data);\n                                }\n                                disconnect();\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Error event\n                        eventSource.addEventListener('error', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                if (event.data) {\n                                    const errorData = JSON.parse(event.data);\n                                    console.error('❌ SSE Error event:', errorData);\n                                    setError(errorData.message);\n                                    if (onErrorRef.current) {\n                                        onErrorRef.current(errorData);\n                                    }\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Generic error handler with polling fallback\n                        eventSource.onerror = ({\n                            \"useSSEStream.useCallback[connect]\": (error)=>{\n                                console.error('❌ SSE Connection error:', error);\n                                setIsConnected(false);\n                                setError('Connection lost. Switching to polling...');\n                                // If connection is closed, fallback to polling\n                                if (eventSource.readyState === EventSource.CLOSED) {\n                                    console.log('🔄 SSE closed, starting polling fallback');\n                                    disconnect();\n                                    startPolling();\n                                }\n                            }\n                        })[\"useSSEStream.useCallback[connect]\"];\n                    } catch (err) {\n                        console.error('❌ Failed to create SSE connection:', err);\n                        setError('Failed to establish connection, using polling');\n                        setIsConnected(false);\n                        isConnectingRef.current = false;\n                        startPolling();\n                    }\n                }\n            }[\"useSSEStream.useCallback[connect]\"]).catch({\n                \"useSSEStream.useCallback[connect]\": (err)=>{\n                    console.error('❌ Failed to check batch status:', err);\n                    setError('Failed to check batch status');\n                    isConnectingRef.current = false;\n                    startPolling() // Fallback to polling if status check fails\n                    ;\n                }\n            }[\"useSSEStream.useCallback[connect]\"]);\n        }\n    }[\"useSSEStream.useCallback[connect]\"], [\n        batchId,\n        backendUrl,\n        startPolling\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[disconnect]\": ()=>{\n            if (eventSourceRef.current) {\n                console.log('🔌 Disconnecting SSE stream');\n                eventSourceRef.current.close();\n                eventSourceRef.current = null;\n                setIsConnected(false);\n            }\n            stopPolling();\n            isConnectingRef.current = false;\n            hasCompletedRef.current = false;\n        }\n    }[\"useSSEStream.useCallback[disconnect]\"], [\n        stopPolling\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            if (batchId) {\n                connect();\n            }\n            return ({\n                \"useSSEStream.useEffect\": ()=>{\n                    // Only disconnect when unmounting or batchId actually changes\n                    if (eventSourceRef.current) {\n                        console.log('🔌 Cleanup: Disconnecting SSE stream');\n                        eventSourceRef.current.close();\n                        eventSourceRef.current = null;\n                    }\n                    if (pollingIntervalRef.current) {\n                        clearInterval(pollingIntervalRef.current);\n                        pollingIntervalRef.current = null;\n                    }\n                }\n            })[\"useSSEStream.useEffect\"];\n        // Only reconnect when batchId changes, not when callbacks change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSSEStream.useEffect\"], [\n        batchId\n    ]);\n    return {\n        isConnected,\n        error,\n        disconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utc3NlLXN0cmVhbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0U7QUFxQ3pELFNBQVNJLGFBQWEsS0FPUDtRQVBPLEVBQzNCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsYUFBYSwrQkFBK0IsMkRBQTJEO0lBQTVELEVBQ3ZCLEdBUE87SUFRM0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTWEsaUJBQWlCZCw2Q0FBTUEsQ0FBcUI7SUFDbEQsTUFBTWUscUJBQXFCZiw2Q0FBTUEsQ0FBd0I7SUFDekQsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBQyxPQUFPLCtCQUErQjs7SUFFckUsd0RBQXdEO0lBQ3hELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBQ0s7SUFDN0IsTUFBTWMsY0FBY25CLDZDQUFNQSxDQUFDTTtJQUMzQixNQUFNYyxnQkFBZ0JwQiw2Q0FBTUEsQ0FBQ087SUFDN0IsTUFBTWMsYUFBYXJCLDZDQUFNQSxDQUFDUTtJQUUxQixvQ0FBb0M7SUFDcENULGdEQUFTQTtrQ0FBQztZQUNSbUIsY0FBY0ksT0FBTyxHQUFHakI7WUFDeEJjLFlBQVlHLE9BQU8sR0FBR2hCO1lBQ3RCYyxjQUFjRSxPQUFPLEdBQUdmO1lBQ3hCYyxXQUFXQyxPQUFPLEdBQUdkO1FBQ3ZCO2lDQUFHO1FBQUNIO1FBQVlDO1FBQVVDO1FBQVlDO0tBQVE7SUFFOUMsNEJBQTRCO0lBQzVCLE1BQU1lLGVBQWVyQixrREFBV0E7a0RBQUM7WUFDL0IsSUFBSWEsbUJBQW1CTyxPQUFPLElBQUlOLGdCQUFnQk0sT0FBTyxFQUFFO2dCQUN6RCxRQUFPLCtCQUErQjtZQUN4QztZ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LEVBQUU7d0JBQzlCb0IsY0FBYzNCLG1CQUFtQk8sT0FBTzt3QkFDeENQLG1CQUFtQk8sT0FBTyxHQUFHO29CQUMvQjtnQkFDRjs7UUFDQSxpRUFBaUU7UUFDakUsdURBQXVEO1FBQ3pEO2lDQUFHO1FBQUNsQjtLQUFRO0lBRVosT0FBTztRQUNMTTtRQUNBRTtRQUNBMEM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRpbGFuXFxEb2N1bWVudHNcXEdpdEh1YlxcV2ViLVNjcmFwcGluZy1Gcm9udGVuZDJcXHNyY1xcaG9va3NcXHVzZS1zc2Utc3RyZWFtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgU2NyYXBpbmdSZXN1bHQgfSBmcm9tICdAL2xpYi9hcGknXHJcblxyXG5pbnRlcmZhY2UgU1NFUHJvZ3Jlc3Mge1xyXG4gIGJhdGNoSWQ6IHN0cmluZ1xyXG4gIGNvbXBsZXRlZDogbnVtYmVyXHJcbiAgdG90YWw6IG51bWJlclxyXG4gIHBlcmNlbnRhZ2U6IG51bWJlclxyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTU0VSZXN1bHQgZXh0ZW5kcyBTY3JhcGluZ1Jlc3VsdCB7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFNTRUNvbXBsZXRlIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBjb21wbGV0ZWQ6IG51bWJlclxyXG4gIHRvdGFsOiBudW1iZXJcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NFRXJyb3Ige1xyXG4gIG1lc3NhZ2U6IHN0cmluZ1xyXG4gIGVycm9yPzogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBVc2VTU0VTdHJlYW1PcHRpb25zIHtcclxuICBiYXRjaElkOiBzdHJpbmcgfCBudWxsXHJcbiAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogU1NFUHJvZ3Jlc3MpID0+IHZvaWRcclxuICBvblJlc3VsdD86IChyZXN1bHQ6IFNTRVJlc3VsdCkgPT4gdm9pZFxyXG4gIG9uQ29tcGxldGU/OiAoY29tcGxldGU6IFNTRUNvbXBsZXRlKSA9PiB2b2lkXHJcbiAgb25FcnJvcj86IChlcnJvcjogU1NFRXJyb3IpID0+IHZvaWRcclxuICBiYWNrZW5kVXJsPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTU0VTdHJlYW0oe1xyXG4gIGJhdGNoSWQsXHJcbiAgb25Qcm9ncmVzcyxcclxuICBvblJlc3VsdCxcclxuICBvbkNvbXBsZXRlLFxyXG4gIG9uRXJyb3IsXHJcbiAgYmFja2VuZFVybCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3YxJyAvLyBDb25uZWN0IERJUkVDVExZIHRvIGJhY2tlbmQgZm9yIFNTRSAocHJveHkgZG9lc24ndCB3b3JrKVxyXG59OiBVc2VTU0VTdHJlYW1PcHRpb25zKSB7XHJcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgZXZlbnRTb3VyY2VSZWYgPSB1c2VSZWY8RXZlbnRTb3VyY2UgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgaGFzQ29tcGxldGVkUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IGlzQ29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSkgLy8gUHJldmVudCBtdWx0aXBsZSBjb25uZWN0aW9uc1xyXG4gIFxyXG4gIC8vIFN0YWJsZSByZWZzIGZvciBjYWxsYmFja3MgdG8gYXZvaWQgcmVjb25uZWN0aW9uIGxvb3BzXHJcbiAgY29uc3Qgb25Qcm9ncmVzc1JlZiA9IHVzZVJlZihvblByb2dyZXNzKVxyXG4gIGNvbnN0IG9uUmVzdWx0UmVmID0gdXNlUmVmKG9uUmVzdWx0KVxyXG4gIGNvbnN0IG9uQ29tcGxldGVSZWYgPSB1c2VSZWYob25Db21wbGV0ZSlcclxuICBjb25zdCBvbkVycm9yUmVmID0gdXNlUmVmKG9uRXJyb3IpXHJcbiAgXHJcbiAgLy8gVXBkYXRlIHJlZnMgd2hlbiBjYWxsYmFja3MgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudCA9IG9uUHJvZ3Jlc3NcclxuICAgIG9uUmVzdWx0UmVmLmN1cnJlbnQgPSBvblJlc3VsdFxyXG4gICAgb25Db21wbGV0ZVJlZi5jdXJyZW50ID0gb25Db21wbGV0ZVxyXG4gICAgb25FcnJvclJlZi5jdXJyZW50ID0gb25FcnJvclxyXG4gIH0sIFtvblByb2dyZXNzLCBvblJlc3VsdCwgb25Db21wbGV0ZSwgb25FcnJvcl0pXHJcblxyXG4gIC8vIFBvbGxpbmcgZmFsbGJhY2sgZnVuY3Rpb25cclxuICBjb25zdCBzdGFydFBvbGxpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgfHwgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuIC8vIEFscmVhZHkgcG9sbGluZyBvciBjb21wbGV0ZWRcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+UhCBTdGFydGluZyBwb2xsaW5nIGZhbGxiYWNrIChldmVyeSAyIHNlY29uZHMpJylcclxuICAgIFxyXG4gICAgcG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGlmICghYmF0Y2hJZCB8fCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgIHN0b3BQb2xsaW5nKClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3YxL3NjcmFwaW5nLWJhdGNoLyR7YmF0Y2hJZH1gKVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBQb2xsaW5nIHVwZGF0ZTonLCBkYXRhLnByb2dyZXNzKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzc1xyXG4gICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQgJiYgZGF0YS5wcm9ncmVzcykge1xyXG4gICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICBjb21wbGV0ZWQ6IGRhdGEucHJvZ3Jlc3MuY29tcGxldGVkLFxyXG4gICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcy50b3RhbCxcclxuICAgICAgICAgICAgcGVyY2VudGFnZTogZGF0YS5wcm9ncmVzcy5wZXJjZW50YWdlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbXBsZXRlZFxyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQmF0Y2ggY29tcGxldGVkIChkZXRlY3RlZCB2aWEgcG9sbGluZyknKVxyXG4gICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZVJlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzPy5jb21wbGV0ZWQgfHwgMCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcz8udG90YWwgfHwgMCxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQmF0Y2ggcHJvY2Vzc2luZyBjb21wbGV0ZWQnLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHN0b3BQb2xsaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBQb2xsaW5nIGVycm9yOicsIGVycilcclxuICAgICAgfVxyXG4gICAgfSwgMjAwMCkgLy8gUG9sbCBldmVyeSAyIHNlY29uZHNcclxuICB9LCBbYmF0Y2hJZF0pXHJcblxyXG4gIGNvbnN0IHN0b3BQb2xsaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfij7nvuI8gU3RvcHBpbmcgcG9sbGluZycpXHJcbiAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpXHJcbiAgICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFiYXRjaElkIHx8IGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50IHx8IGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gU2tpcHBpbmcgY29ubmVjdGlvbiAtIGJhdGNoSWQ6JywgYmF0Y2hJZCwgJ2Nvbm5lY3Rpbmc6JywgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQsICdjb21wbGV0ZWQ6JywgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgY29uc29sZS5sb2coJ/CflIwgQ29ubmVjdGluZyB0byBTU0Ugc3RyZWFtIGZvciBiYXRjaDonLCBiYXRjaElkKVxyXG4gICAgY29uc29sZS5sb2coJ/Cfk6EgQmFja2VuZCBVUkw6JywgYmFja2VuZFVybClcclxuICAgIFxyXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBiYXRjaCBpcyBhbHJlYWR5IGNvbXBsZXRlXHJcbiAgICBmZXRjaChgL2FwaS92MS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9YClcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXHJcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEJhdGNoIHN0YXR1czonLCBkYXRhLnN0YXR1cylcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEJhdGNoIGFscmVhZHkgY29tcGxldGVkLCB0cmlnZ2VyaW5nIG9uQ29tcGxldGUgd2l0aCBwcm9ncmVzczonLCBkYXRhLnByb2dyZXNzKVxyXG4gICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBpZiB3ZSBoYXZlIHRoZSBkYXRhXHJcbiAgICAgICAgICBpZiAob25Qcm9ncmVzc1JlZi5jdXJyZW50ICYmIGRhdGEucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzLmNvbXBsZXRlZCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcy50b3RhbCxcclxuICAgICAgICAgICAgICBwZXJjZW50YWdlOiBkYXRhLnByb2dyZXNzLnBlcmNlbnRhZ2UgfHwgMTAwLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZVJlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzPy5jb21wbGV0ZWQgfHwgMCxcclxuICAgICAgICAgICAgICB0b3RhbDogZGF0YS5wcm9ncmVzcz8udG90YWwgfHwgMCxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQmF0Y2ggcHJvY2Vzc2luZyBhbHJlYWR5IGNvbXBsZXRlZCcsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiAvLyBEb24ndCBjb25uZWN0IHRvIFNTRSBpZiBhbHJlYWR5IGNvbXBsZXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vdCBjb21wbGV0ZSwgY29ubmVjdCB0byBTU0VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgdXJsID0gYCR7YmFja2VuZFVybH0vc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfS9zdHJlYW1gXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UlyBTU0UgVVJMOicsIHVybClcclxuICAgICAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybClcclxuICAgICAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQgPSBldmVudFNvdXJjZVxyXG5cclxuICAgICAgICAgIC8vIENvbm5lY3RlZCBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGVkJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgU1NFIENvbm5lY3RlZDonLCBkYXRhKVxyXG4gICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKVxyXG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKVxyXG4gICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIFByb2dyZXNzIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBTU0VQcm9ncmVzcyA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgLy8gT25seSBsb2cgcHJvZ3Jlc3MgdXBkYXRlcywgbm90IGV2ZXJ5IDItc2Vjb25kIHBpbmdcclxuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3NSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudChkYXRhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIFJlc3VsdCBldmVudCAoaW5kaXZpZHVhbCBidXNpbmVzcyByZXN1bHQpXHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdyZXN1bHQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBTU0VSZXN1bHQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgIC8vIERvbid0IGxvZyBldmVyeSByZXN1bHQgKGJhY2tlbmQgc2VuZHMgZHVwbGljYXRlcyBvbiBlYWNoIHByb2dyZXNzIGV2ZW50KVxyXG4gICAgICAgICAgICBpZiAob25SZXN1bHRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIG9uUmVzdWx0UmVmLmN1cnJlbnQocmVzdWx0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIENvbXBsZXRlIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhOiBTU0VDb21wbGV0ZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTU0UgQ29tcGxldGU6JywgZGF0YSlcclxuICAgICAgICAgICAgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvbkNvbXBsZXRlUmVmLmN1cnJlbnQoZGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXNjb25uZWN0KClcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gRXJyb3IgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEpIHtcclxuICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGE6IFNTRUVycm9yID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTU0UgRXJyb3IgZXZlbnQ6JywgZXJyb3JEYXRhKVxyXG4gICAgICAgICAgICAgIHNldEVycm9yKGVycm9yRGF0YS5tZXNzYWdlKVxyXG4gICAgICAgICAgICAgIGlmIChvbkVycm9yUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3JSZWYuY3VycmVudChlcnJvckRhdGEpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIC8vIEdlbmVyaWMgZXJyb3IgaGFuZGxlciB3aXRoIHBvbGxpbmcgZmFsbGJhY2tcclxuICAgICAgICAgIGV2ZW50U291cmNlLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNTRSBDb25uZWN0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcclxuICAgICAgICAgICAgc2V0RXJyb3IoJ0Nvbm5lY3Rpb24gbG9zdC4gU3dpdGNoaW5nIHRvIHBvbGxpbmcuLi4nKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgY29ubmVjdGlvbiBpcyBjbG9zZWQsIGZhbGxiYWNrIHRvIHBvbGxpbmdcclxuICAgICAgICAgICAgaWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFNTRSBjbG9zZWQsIHN0YXJ0aW5nIHBvbGxpbmcgZmFsbGJhY2snKVxyXG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgICAgIHN0YXJ0UG9sbGluZygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNyZWF0ZSBTU0UgY29ubmVjdGlvbjonLCBlcnIpXHJcbiAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGVzdGFibGlzaCBjb25uZWN0aW9uLCB1c2luZyBwb2xsaW5nJylcclxuICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxyXG4gICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgc3RhcnRQb2xsaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gY2hlY2sgYmF0Y2ggc3RhdHVzOicsIGVycilcclxuICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGNoZWNrIGJhdGNoIHN0YXR1cycpXHJcbiAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgIHN0YXJ0UG9sbGluZygpIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgc3RhdHVzIGNoZWNrIGZhaWxzXHJcbiAgICAgIH0pXHJcbiAgfSwgW2JhdGNoSWQsIGJhY2tlbmRVcmwsIHN0YXJ0UG9sbGluZ10pXHJcblxyXG4gIGNvbnN0IGRpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoZXZlbnRTb3VyY2VSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjCBEaXNjb25uZWN0aW5nIFNTRSBzdHJlYW0nKVxyXG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICB9XHJcbiAgICBzdG9wUG9sbGluZygpXHJcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgfSwgW3N0b3BQb2xsaW5nXSlcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChiYXRjaElkKSB7XHJcbiAgICAgIGNvbm5lY3QoKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIC8vIE9ubHkgZGlzY29ubmVjdCB3aGVuIHVubW91bnRpbmcgb3IgYmF0Y2hJZCBhY3R1YWxseSBjaGFuZ2VzXHJcbiAgICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIwgQ2xlYW51cDogRGlzY29ubmVjdGluZyBTU0Ugc3RyZWFtJylcclxuICAgICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50LmNsb3NlKClcclxuICAgICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgcG9sbGluZ0ludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE9ubHkgcmVjb25uZWN0IHdoZW4gYmF0Y2hJZCBjaGFuZ2VzLCBub3Qgd2hlbiBjYWxsYmFja3MgY2hhbmdlXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW2JhdGNoSWRdKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaXNDb25uZWN0ZWQsXHJcbiAgICBlcnJvcixcclxuICAgIGRpc2Nvbm5lY3RcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTU0VTdHJlYW0iLCJiYXRjaElkIiwib25Qcm9ncmVzcyIsIm9uUmVzdWx0Iiwib25Db21wbGV0ZSIsIm9uRXJyb3IiLCJiYWNrZW5kVXJsIiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImVycm9yIiwic2V0RXJyb3IiLCJldmVudFNvdXJjZVJlZiIsInBvbGxpbmdJbnRlcnZhbFJlZiIsImhhc0NvbXBsZXRlZFJlZiIsImlzQ29ubmVjdGluZ1JlZiIsIm9uUHJvZ3Jlc3NSZWYiLCJvblJlc3VsdFJlZiIsIm9uQ29tcGxldGVSZWYiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInN0YXJ0UG9sbGluZyIsImNvbnNvbGUiLCJsb2ciLCJzZXRJbnRlcnZhbCIsInN0b3BQb2xsaW5nIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicHJvZ3Jlc3MiLCJjb21wbGV0ZWQiLCJ0b3RhbCIsInBlcmNlbnRhZ2UiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzdGF0dXMiLCJtZXNzYWdlIiwiZXJyIiwiY2xlYXJJbnRlcnZhbCIsImNvbm5lY3QiLCJ0aGVuIiwicmVzIiwidXJsIiwiZXZlbnRTb3VyY2UiLCJFdmVudFNvdXJjZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIkpTT04iLCJwYXJzZSIsInJlc3VsdCIsImRpc2Nvbm5lY3QiLCJlcnJvckRhdGEiLCJvbmVycm9yIiwicmVhZHlTdGF0ZSIsIkNMT1NFRCIsImNhdGNoIiwiY2xvc2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-sse-stream.ts\n"));

/***/ })

});