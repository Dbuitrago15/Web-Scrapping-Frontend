"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-sse-stream.ts":
/*!*************************************!*\
  !*** ./src/hooks/use-sse-stream.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSEStream: () => (/* binding */ useSSEStream)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useSSEStream(param) {\n    let { batchId, onProgress, onResult, onComplete, onError, backendUrl = 'http://localhost:3000/api/v1' // Connect DIRECTLY to backend for SSE (proxy doesn't work)\n     } = param;\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const eventSourceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const pollingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hasCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false) // Prevent multiple connections\n    ;\n    // Stable refs for callbacks to avoid reconnection loops\n    const onProgressRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onProgress);\n    const onResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onResult);\n    const onCompleteRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onComplete);\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    // Update refs when callbacks change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            onProgressRef.current = onProgress;\n            onResultRef.current = onResult;\n            onCompleteRef.current = onComplete;\n            onErrorRef.current = onError;\n        }\n    }[\"useSSEStream.useEffect\"], [\n        onProgress,\n        onResult,\n        onComplete,\n        onError\n    ]);\n    // Polling fallback function\n    const startPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[startPolling]\": ()=>{\n            if (pollingIntervalRef.current || hasCompletedRef.current) {\n                return; // Already polling or completed\n            }\n            console.log('🔄 Starting polling fallback (every 2 seconds)');\n            pollingIntervalRef.current = setInterval({\n                \"useSSEStream.useCallback[startPolling]\": async ()=>{\n                    if (!batchId || hasCompletedRef.current) {\n                        stopPolling();\n                        return;\n                    }\n                    try {\n                        const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId));\n                        const data = await response.json();\n                        console.log('📊 Polling update:', data.progress);\n                        // Update progress\n                        if (onProgressRef.current && data.progress) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: data.progress.completed,\n                                total: data.progress.total,\n                                percentage: data.progress.percentage,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                        // Check if completed\n                        if (data.status === 'completed') {\n                            console.log('✅ Batch completed (detected via polling)');\n                            hasCompletedRef.current = true;\n                            if (onCompleteRef.current) {\n                                var _data_progress, _data_progress1;\n                                onCompleteRef.current({\n                                    batchId: data.batchId,\n                                    completed: ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.completed) || 0,\n                                    total: ((_data_progress1 = data.progress) === null || _data_progress1 === void 0 ? void 0 : _data_progress1.total) || 0,\n                                    message: 'Batch processing completed',\n                                    timestamp: new Date().toISOString()\n                                });\n                            }\n                            stopPolling();\n                        }\n                    } catch (err) {\n                        console.error('❌ Polling error:', err);\n                    }\n                }\n            }[\"useSSEStream.useCallback[startPolling]\"], 2000) // Poll every 2 seconds\n            ;\n        }\n    }[\"useSSEStream.useCallback[startPolling]\"], [\n        batchId\n    ]);\n    const stopPolling = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[stopPolling]\": ()=>{\n            if (pollingIntervalRef.current) {\n                console.log('⏹️ Stopping polling');\n                clearInterval(pollingIntervalRef.current);\n                pollingIntervalRef.current = null;\n            }\n        }\n    }[\"useSSEStream.useCallback[stopPolling]\"], []);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[connect]\": ()=>{\n            if (!batchId || isConnectingRef.current || hasCompletedRef.current) {\n                console.log('⚠️ Skipping connection - batchId:', batchId, 'connecting:', isConnectingRef.current, 'completed:', hasCompletedRef.current);\n                return;\n            }\n            isConnectingRef.current = true;\n            console.log('🔌 Connecting to SSE stream for batch:', batchId);\n            console.log('📡 Backend URL:', backendUrl);\n            // First, check if the batch is already complete\n            fetch(\"/api/v1/scraping-batch/\".concat(batchId)).then({\n                \"useSSEStream.useCallback[connect]\": (res)=>res.json()\n            }[\"useSSEStream.useCallback[connect]\"]).then({\n                \"useSSEStream.useCallback[connect]\": (data)=>{\n                    var _data_progress;\n                    console.log('📋 Batch status:', data.status);\n                    // If batch is completed, still connect to SSE to get the results\n                    // But store the total so we know when to auto-complete\n                    const isAlreadyCompleted = data.status === 'completed';\n                    const totalFromBatch = ((_data_progress = data.progress) === null || _data_progress === void 0 ? void 0 : _data_progress.total) || data.totalJobs || 0;\n                    if (isAlreadyCompleted) {\n                        console.log('✅ Batch already completed, connecting to SSE to fetch results. Total:', totalFromBatch);\n                        // Update progress with the total so the component knows how many to expect\n                        if (onProgressRef.current && totalFromBatch > 0) {\n                            onProgressRef.current({\n                                batchId: data.batchId,\n                                completed: 0,\n                                total: totalFromBatch,\n                                percentage: 0,\n                                timestamp: new Date().toISOString()\n                            });\n                        }\n                    }\n                    // If not complete, connect to SSE\n                    try {\n                        const url = \"\".concat(backendUrl, \"/scraping-batch/\").concat(batchId, \"/stream\");\n                        console.log('🔗 SSE URL:', url);\n                        const eventSource = new EventSource(url);\n                        eventSourceRef.current = eventSource;\n                        // Connected event\n                        eventSource.addEventListener('connected', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Connected:', data);\n                                setIsConnected(true);\n                                setError(null);\n                                isConnectingRef.current = false;\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Progress event\n                        eventSource.addEventListener('progress', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('📊 Progress data received:', data);\n                                // Only log progress updates, not every 2-second ping\n                                if (onProgressRef.current) {\n                                    onProgressRef.current(data);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Result event (individual business result)\n                        eventSource.addEventListener('result', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                var _result_originalData;\n                                const result = JSON.parse(event.data);\n                                console.log('📦 Result received:', (_result_originalData = result.originalData) === null || _result_originalData === void 0 ? void 0 : _result_originalData.name);\n                                // Don't log every result (backend sends duplicates on each progress event)\n                                if (onResultRef.current) {\n                                    onResultRef.current(result);\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Complete event\n                        eventSource.addEventListener('complete', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                const data = JSON.parse(event.data);\n                                console.log('✅ SSE Complete:', data);\n                                hasCompletedRef.current = true;\n                                if (onCompleteRef.current) {\n                                    onCompleteRef.current(data);\n                                }\n                                disconnect();\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Error event\n                        eventSource.addEventListener('error', {\n                            \"useSSEStream.useCallback[connect]\": (event)=>{\n                                if (event.data) {\n                                    const errorData = JSON.parse(event.data);\n                                    console.error('❌ SSE Error event:', errorData);\n                                    setError(errorData.message);\n                                    if (onErrorRef.current) {\n                                        onErrorRef.current(errorData);\n                                    }\n                                }\n                            }\n                        }[\"useSSEStream.useCallback[connect]\"]);\n                        // Generic error handler with polling fallback\n                        eventSource.onerror = ({\n                            \"useSSEStream.useCallback[connect]\": (error)=>{\n                                console.error('❌ SSE Connection error:', error);\n                                setIsConnected(false);\n                                setError('Connection lost. Switching to polling...');\n                                // If connection is closed, fallback to polling\n                                if (eventSource.readyState === EventSource.CLOSED) {\n                                    console.log('🔄 SSE closed, starting polling fallback');\n                                    disconnect();\n                                    startPolling();\n                                }\n                            }\n                        })[\"useSSEStream.useCallback[connect]\"];\n                    } catch (err) {\n                        console.error('❌ Failed to create SSE connection:', err);\n                        setError('Failed to establish connection, using polling');\n                        setIsConnected(false);\n                        isConnectingRef.current = false;\n                        startPolling();\n                    }\n                }\n            }[\"useSSEStream.useCallback[connect]\"]).catch({\n                \"useSSEStream.useCallback[connect]\": (err)=>{\n                    console.error('❌ Failed to check batch status:', err);\n                    setError('Failed to check batch status');\n                    isConnectingRef.current = false;\n                    startPolling() // Fallback to polling if status check fails\n                    ;\n                }\n            }[\"useSSEStream.useCallback[connect]\"]);\n        }\n    }[\"useSSEStream.useCallback[connect]\"], [\n        batchId,\n        backendUrl,\n        startPolling\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSSEStream.useCallback[disconnect]\": ()=>{\n            if (eventSourceRef.current) {\n                console.log('🔌 Disconnecting SSE stream');\n                eventSourceRef.current.close();\n                eventSourceRef.current = null;\n                setIsConnected(false);\n            }\n            stopPolling();\n            isConnectingRef.current = false;\n            hasCompletedRef.current = false;\n        }\n    }[\"useSSEStream.useCallback[disconnect]\"], [\n        stopPolling\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSSEStream.useEffect\": ()=>{\n            if (batchId) {\n                connect();\n            }\n            return ({\n                \"useSSEStream.useEffect\": ()=>{\n                    // Only disconnect when unmounting or batchId actually changes\n                    if (eventSourceRef.current) {\n                        console.log('🔌 Cleanup: Disconnecting SSE stream');\n                        eventSourceRef.current.close();\n                        eventSourceRef.current = null;\n                    }\n                    if (pollingIntervalRef.current) {\n                        clearInterval(pollingIntervalRef.current);\n                        pollingIntervalRef.current = null;\n                    }\n                }\n            })[\"useSSEStream.useEffect\"];\n        // Only reconnect when batchId changes, not when callbacks change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useSSEStream.useEffect\"], [\n        batchId\n    ]);\n    return {\n        isConnected,\n        error,\n        disconnect\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2Utc3NlLXN0cmVhbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0U7QUFxQ3pELFNBQVNJLGFBQWEsS0FPUDtRQVBPLEVBQzNCQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsYUFBYSwrQkFBK0IsMkRBQTJEO0lBQTVELEVBQ3ZCLEdBUE87SUFRM0IsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTWEsaUJBQWlCZCw2Q0FBTUEsQ0FBcUI7SUFDbEQsTUFBTWUscUJBQXFCZiw2Q0FBTUEsQ0FBd0I7SUFDekQsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU1pQixrQkFBa0JqQiw2Q0FBTUEsQ0FBQyxPQUFPLCtCQUErQjs7SUFFckUsd0RBQXdEO0lBQ3hELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBQ0s7SUFDN0IsTUFBTWMsY0FBY25CLDZDQUFNQSxDQUFDTTtJQUMzQixNQUFNYyxnQkFBZ0JwQiw2Q0FBTUEsQ0FBQ087SUFDN0IsTUFBTWMsYUFBYXJCLDZDQUFNQSxDQUFDUTtJQUUxQixvQ0FBb0M7SUFDcENULGdEQUFTQTtrQ0FBQztZQUNSbUIsY0FBY0ksT0FBTyxHQUFHakI7WUFDeEJjLFlBQVlHLE9BQU8sR0FBR2hCO1lBQ3RCYyxjQUFjRSxPQUFPLEdBQUdmO1lBQ3hCYyxXQUFXQyxPQUFPLEdBQUdkO1FBQ3ZCO2lDQUFHO1FBQUNIO1FBQVlDO1FBQVVDO1FBQVlDO0tBQVE7SUFFOUMsNEJBQTRCO0lBQzVCLE1BQU1lLGVBQWVyQixrREFBV0E7a0RBQUM7WUFDL0IsSUFBSWEsbUJBQW1CTyxPQUFPLElBQUlOLGdCQUFnQk0sT0FBTyxFQUFFO2dCQUN6RCxRQUFPLCtCQUErQjtZQUN4QztZ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ZXMiOlsiQzpcXFVzZXJzXFxkaWxhblxcRG9jdW1lbnRzXFxHaXRIdWJcXFdlYi1TY3JhcHBpbmctRnJvbnRlbmQyXFxzcmNcXGhvb2tzXFx1c2Utc3NlLXN0cmVhbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IFNjcmFwaW5nUmVzdWx0IH0gZnJvbSAnQC9saWIvYXBpJ1xyXG5cclxuaW50ZXJmYWNlIFNTRVByb2dyZXNzIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBjb21wbGV0ZWQ6IG51bWJlclxyXG4gIHRvdGFsOiBudW1iZXJcclxuICBwZXJjZW50YWdlOiBudW1iZXJcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NFUmVzdWx0IGV4dGVuZHMgU2NyYXBpbmdSZXN1bHQge1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBTU0VDb21wbGV0ZSB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nXHJcbiAgY29tcGxldGVkOiBudW1iZXJcclxuICB0b3RhbDogbnVtYmVyXHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBzdHJpbmdcclxufVxyXG5cclxuaW50ZXJmYWNlIFNTRUVycm9yIHtcclxuICBtZXNzYWdlOiBzdHJpbmdcclxuICBlcnJvcj86IHN0cmluZ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVXNlU1NFU3RyZWFtT3B0aW9ucyB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nIHwgbnVsbFxyXG4gIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IFNTRVByb2dyZXNzKSA9PiB2b2lkXHJcbiAgb25SZXN1bHQ/OiAocmVzdWx0OiBTU0VSZXN1bHQpID0+IHZvaWRcclxuICBvbkNvbXBsZXRlPzogKGNvbXBsZXRlOiBTU0VDb21wbGV0ZSkgPT4gdm9pZFxyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IFNTRUVycm9yKSA9PiB2b2lkXHJcbiAgYmFja2VuZFVybD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU1NFU3RyZWFtKHtcclxuICBiYXRjaElkLFxyXG4gIG9uUHJvZ3Jlc3MsXHJcbiAgb25SZXN1bHQsXHJcbiAgb25Db21wbGV0ZSxcclxuICBvbkVycm9yLFxyXG4gIGJhY2tlbmRVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS92MScgLy8gQ29ubmVjdCBESVJFQ1RMWSB0byBiYWNrZW5kIGZvciBTU0UgKHByb3h5IGRvZXNuJ3Qgd29yaylcclxufTogVXNlU1NFU3RyZWFtT3B0aW9ucykge1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGV2ZW50U291cmNlUmVmID0gdXNlUmVmPEV2ZW50U291cmNlIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWxSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGhhc0NvbXBsZXRlZFJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCBpc0Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpIC8vIFByZXZlbnQgbXVsdGlwbGUgY29ubmVjdGlvbnNcclxuICBcclxuICAvLyBTdGFibGUgcmVmcyBmb3IgY2FsbGJhY2tzIHRvIGF2b2lkIHJlY29ubmVjdGlvbiBsb29wc1xyXG4gIGNvbnN0IG9uUHJvZ3Jlc3NSZWYgPSB1c2VSZWYob25Qcm9ncmVzcylcclxuICBjb25zdCBvblJlc3VsdFJlZiA9IHVzZVJlZihvblJlc3VsdClcclxuICBjb25zdCBvbkNvbXBsZXRlUmVmID0gdXNlUmVmKG9uQ29tcGxldGUpXHJcbiAgY29uc3Qgb25FcnJvclJlZiA9IHVzZVJlZihvbkVycm9yKVxyXG4gIFxyXG4gIC8vIFVwZGF0ZSByZWZzIHdoZW4gY2FsbGJhY2tzIGNoYW5nZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQgPSBvblByb2dyZXNzXHJcbiAgICBvblJlc3VsdFJlZi5jdXJyZW50ID0gb25SZXN1bHRcclxuICAgIG9uQ29tcGxldGVSZWYuY3VycmVudCA9IG9uQ29tcGxldGVcclxuICAgIG9uRXJyb3JSZWYuY3VycmVudCA9IG9uRXJyb3JcclxuICB9LCBbb25Qcm9ncmVzcywgb25SZXN1bHQsIG9uQ29tcGxldGUsIG9uRXJyb3JdKVxyXG5cclxuICAvLyBQb2xsaW5nIGZhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgY29uc3Qgc3RhcnRQb2xsaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50IHx8IGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVybiAvLyBBbHJlYWR5IHBvbGxpbmcgb3IgY29tcGxldGVkXHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/CflIQgU3RhcnRpbmcgcG9sbGluZyBmYWxsYmFjayAoZXZlcnkgMiBzZWNvbmRzKScpXHJcbiAgICBcclxuICAgIHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoIWJhdGNoSWQgfHwgaGFzQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBzdG9wUG9sbGluZygpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS92MS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9YClcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUG9sbGluZyB1cGRhdGU6JywgZGF0YS5wcm9ncmVzcylcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3NcclxuICAgICAgICBpZiAob25Qcm9ncmVzc1JlZi5jdXJyZW50ICYmIGRhdGEucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgIG9uUHJvZ3Jlc3NSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgIGJhdGNoSWQ6IGRhdGEuYmF0Y2hJZCxcclxuICAgICAgICAgICAgY29tcGxldGVkOiBkYXRhLnByb2dyZXNzLmNvbXBsZXRlZCxcclxuICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3MudG90YWwsXHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IGRhdGEucHJvZ3Jlc3MucGVyY2VudGFnZSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBjb21wbGV0ZWRcclxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEJhdGNoIGNvbXBsZXRlZCAoZGV0ZWN0ZWQgdmlhIHBvbGxpbmcpJylcclxuICAgICAgICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAob25Db21wbGV0ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVSZWYuY3VycmVudCh7XHJcbiAgICAgICAgICAgICAgYmF0Y2hJZDogZGF0YS5iYXRjaElkLFxyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogZGF0YS5wcm9ncmVzcz8uY29tcGxldGVkIHx8IDAsXHJcbiAgICAgICAgICAgICAgdG90YWw6IGRhdGEucHJvZ3Jlc3M/LnRvdGFsIHx8IDAsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0JhdGNoIHByb2Nlc3NpbmcgY29tcGxldGVkJyxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBzdG9wUG9sbGluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgUG9sbGluZyBlcnJvcjonLCBlcnIpXHJcbiAgICAgIH1cclxuICAgIH0sIDIwMDApIC8vIFBvbGwgZXZlcnkgMiBzZWNvbmRzXHJcbiAgfSwgW2JhdGNoSWRdKVxyXG5cclxuICBjb25zdCBzdG9wUG9sbGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4o+577iPIFN0b3BwaW5nIHBvbGxpbmcnKVxyXG4gICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50KVxyXG4gICAgICBwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmICghYmF0Y2hJZCB8fCBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pqg77iPIFNraXBwaW5nIGNvbm5lY3Rpb24gLSBiYXRjaElkOicsIGJhdGNoSWQsICdjb25uZWN0aW5nOicsIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50LCAnY29tcGxldGVkOicsIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50KVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IHRydWVcclxuICAgIGNvbnNvbGUubG9nKCfwn5SMIENvbm5lY3RpbmcgdG8gU1NFIHN0cmVhbSBmb3IgYmF0Y2g6JywgYmF0Y2hJZClcclxuICAgIGNvbnNvbGUubG9nKCfwn5OhIEJhY2tlbmQgVVJMOicsIGJhY2tlbmRVcmwpXHJcbiAgICBcclxuICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgYmF0Y2ggaXMgYWxyZWFkeSBjb21wbGV0ZVxyXG4gICAgZmV0Y2goYC9hcGkvdjEvc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfWApXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxyXG4gICAgICAudGhlbihkYXRhID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBCYXRjaCBzdGF0dXM6JywgZGF0YS5zdGF0dXMpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgYmF0Y2ggaXMgY29tcGxldGVkLCBzdGlsbCBjb25uZWN0IHRvIFNTRSB0byBnZXQgdGhlIHJlc3VsdHNcclxuICAgICAgICAvLyBCdXQgc3RvcmUgdGhlIHRvdGFsIHNvIHdlIGtub3cgd2hlbiB0byBhdXRvLWNvbXBsZXRlXHJcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5Q29tcGxldGVkID0gZGF0YS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnXHJcbiAgICAgICAgY29uc3QgdG90YWxGcm9tQmF0Y2ggPSBkYXRhLnByb2dyZXNzPy50b3RhbCB8fCBkYXRhLnRvdGFsSm9icyB8fCAwXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGlzQWxyZWFkeUNvbXBsZXRlZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBCYXRjaCBhbHJlYWR5IGNvbXBsZXRlZCwgY29ubmVjdGluZyB0byBTU0UgdG8gZmV0Y2ggcmVzdWx0cy4gVG90YWw6JywgdG90YWxGcm9tQmF0Y2gpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyB3aXRoIHRoZSB0b3RhbCBzbyB0aGUgY29tcG9uZW50IGtub3dzIGhvdyBtYW55IHRvIGV4cGVjdFxyXG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3NSZWYuY3VycmVudCAmJiB0b3RhbEZyb21CYXRjaCA+IDApIHtcclxuICAgICAgICAgICAgb25Qcm9ncmVzc1JlZi5jdXJyZW50KHtcclxuICAgICAgICAgICAgICBiYXRjaElkOiBkYXRhLmJhdGNoSWQsXHJcbiAgICAgICAgICAgICAgY29tcGxldGVkOiAwLCAvLyBXaWxsIGJlIHVwZGF0ZWQgYXMgcmVzdWx0cyBjb21lIGluXHJcbiAgICAgICAgICAgICAgdG90YWw6IHRvdGFsRnJvbUJhdGNoLFxyXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IDAsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgbm90IGNvbXBsZXRlLCBjb25uZWN0IHRvIFNTRVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB1cmwgPSBgJHtiYWNrZW5kVXJsfS9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9L3N0cmVhbWBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SXIFNTRSBVUkw6JywgdXJsKVxyXG4gICAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UodXJsKVxyXG4gICAgICAgICAgZXZlbnRTb3VyY2VSZWYuY3VycmVudCA9IGV2ZW50U291cmNlXHJcblxyXG4gICAgICAgICAgLy8gQ29ubmVjdGVkIGV2ZW50XHJcbiAgICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0ZWQnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBTU0UgQ29ubmVjdGVkOicsIGRhdGEpXHJcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXHJcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpXHJcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gUHJvZ3Jlc3MgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IFNTRVByb2dyZXNzID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBQcm9ncmVzcyBkYXRhIHJlY2VpdmVkOicsIGRhdGEpXHJcbiAgICAgICAgICAgIC8vIE9ubHkgbG9nIHByb2dyZXNzIHVwZGF0ZXMsIG5vdCBldmVyeSAyLXNlY29uZCBwaW5nXHJcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBvblByb2dyZXNzUmVmLmN1cnJlbnQoZGF0YSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBSZXN1bHQgZXZlbnQgKGluZGl2aWR1YWwgYnVzaW5lc3MgcmVzdWx0KVxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncmVzdWx0JywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogU1NFUmVzdWx0ID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBSZXN1bHQgcmVjZWl2ZWQ6JywgcmVzdWx0Lm9yaWdpbmFsRGF0YT8ubmFtZSlcclxuICAgICAgICAgICAgLy8gRG9uJ3QgbG9nIGV2ZXJ5IHJlc3VsdCAoYmFja2VuZCBzZW5kcyBkdXBsaWNhdGVzIG9uIGVhY2ggcHJvZ3Jlc3MgZXZlbnQpXHJcbiAgICAgICAgICAgIGlmIChvblJlc3VsdFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgb25SZXN1bHRSZWYuY3VycmVudChyZXN1bHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gQ29tcGxldGUgZXZlbnRcclxuICAgICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGE6IFNTRUNvbXBsZXRlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNTRSBDb21wbGV0ZTonLCBkYXRhKVxyXG4gICAgICAgICAgICBoYXNDb21wbGV0ZWRSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIG9uQ29tcGxldGVSZWYuY3VycmVudChkYXRhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAvLyBFcnJvciBldmVudFxyXG4gICAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YTogU1NFRXJyb3IgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFNTRSBFcnJvciBldmVudDonLCBlcnJvckRhdGEpXHJcbiAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgaWYgKG9uRXJyb3JSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvclJlZi5jdXJyZW50KGVycm9yRGF0YSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgLy8gR2VuZXJpYyBlcnJvciBoYW5kbGVyIHdpdGggcG9sbGluZyBmYWxsYmFja1xyXG4gICAgICAgICAgZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgU1NFIENvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpXHJcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKVxyXG4gICAgICAgICAgICBzZXRFcnJvcignQ29ubmVjdGlvbiBsb3N0LiBTd2l0Y2hpbmcgdG8gcG9sbGluZy4uLicpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBjb25uZWN0aW9uIGlzIGNsb3NlZCwgZmFsbGJhY2sgdG8gcG9sbGluZ1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflIQgU1NFIGNsb3NlZCwgc3RhcnRpbmcgcG9sbGluZyBmYWxsYmFjaycpXHJcbiAgICAgICAgICAgICAgZGlzY29ubmVjdCgpXHJcbiAgICAgICAgICAgICAgc3RhcnRQb2xsaW5nKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gY3JlYXRlIFNTRSBjb25uZWN0aW9uOicsIGVycilcclxuICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24sIHVzaW5nIHBvbGxpbmcnKVxyXG4gICAgICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXHJcbiAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBzdGFydFBvbGxpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBjaGVjayBiYXRjaCBzdGF0dXM6JywgZXJyKVxyXG4gICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY2hlY2sgYmF0Y2ggc3RhdHVzJylcclxuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgc3RhcnRQb2xsaW5nKCkgLy8gRmFsbGJhY2sgdG8gcG9sbGluZyBpZiBzdGF0dXMgY2hlY2sgZmFpbHNcclxuICAgICAgfSlcclxuICB9LCBbYmF0Y2hJZCwgYmFja2VuZFVybCwgc3RhcnRQb2xsaW5nXSlcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChldmVudFNvdXJjZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SMIERpc2Nvbm5lY3RpbmcgU1NFIHN0cmVhbScpXHJcbiAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICBldmVudFNvdXJjZVJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcclxuICAgIH1cclxuICAgIHN0b3BQb2xsaW5nKClcclxuICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIGhhc0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gZmFsc2VcclxuICB9LCBbc3RvcFBvbGxpbmddKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGJhdGNoSWQpIHtcclxuICAgICAgY29ubmVjdCgpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gT25seSBkaXNjb25uZWN0IHdoZW4gdW5tb3VudGluZyBvciBiYXRjaElkIGFjdHVhbGx5IGNoYW5nZXNcclxuICAgICAgaWYgKGV2ZW50U291cmNlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjCBDbGVhbnVwOiBEaXNjb25uZWN0aW5nIFNTRSBzdHJlYW0nKVxyXG4gICAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQuY2xvc2UoKVxyXG4gICAgICAgIGV2ZW50U291cmNlUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudClcclxuICAgICAgICBwb2xsaW5nSW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gT25seSByZWNvbm5lY3Qgd2hlbiBiYXRjaElkIGNoYW5nZXMsIG5vdCB3aGVuIGNhbGxiYWNrcyBjaGFuZ2VcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICB9LCBbYmF0Y2hJZF0pXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpc0Nvbm5lY3RlZCxcclxuICAgIGVycm9yLFxyXG4gICAgZGlzY29ubmVjdFxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVNTRVN0cmVhbSIsImJhdGNoSWQiLCJvblByb2dyZXNzIiwib25SZXN1bHQiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsImJhY2tlbmRVcmwiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiZXJyb3IiLCJzZXRFcnJvciIsImV2ZW50U291cmNlUmVmIiwicG9sbGluZ0ludGVydmFsUmVmIiwiaGFzQ29tcGxldGVkUmVmIiwiaXNDb25uZWN0aW5nUmVmIiwib25Qcm9ncmVzc1JlZiIsIm9uUmVzdWx0UmVmIiwib25Db21wbGV0ZVJlZiIsIm9uRXJyb3JSZWYiLCJjdXJyZW50Iiwic3RhcnRQb2xsaW5nIiwiY29uc29sZSIsImxvZyIsInNldEludGVydmFsIiwic3RvcFBvbGxpbmciLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJwcm9ncmVzcyIsImNvbXBsZXRlZCIsInRvdGFsIiwicGVyY2VudGFnZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInN0YXR1cyIsIm1lc3NhZ2UiLCJlcnIiLCJjbGVhckludGVydmFsIiwiY29ubmVjdCIsInRoZW4iLCJyZXMiLCJpc0FscmVhZHlDb21wbGV0ZWQiLCJ0b3RhbEZyb21CYXRjaCIsInRvdGFsSm9icyIsInVybCIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJKU09OIiwicGFyc2UiLCJyZXN1bHQiLCJvcmlnaW5hbERhdGEiLCJuYW1lIiwiZGlzY29ubmVjdCIsImVycm9yRGF0YSIsIm9uZXJyb3IiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwiY2F0Y2giLCJjbG9zZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-sse-stream.ts\n"));

/***/ })

});