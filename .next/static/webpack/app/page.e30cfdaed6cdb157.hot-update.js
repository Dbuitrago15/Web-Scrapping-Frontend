"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiService: () => (/* binding */ ApiService),\n/* harmony export */   getProgress: () => (/* binding */ getProgress)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug */ \"(app-pages-browser)/./src/lib/debug.ts\");\n\n\n// Base URL del backend - usar proxy de Next.js en desarrollo para evitar CORS\nconst API_BASE_URL =  false ? 0 : '/api/v1' // Usar proxy de Next.js en desarrollo\n;\nconsole.log('ðŸ”§ API Configuration:');\nconsole.log('ðŸ“ Base URL:', API_BASE_URL);\nconsole.log('ðŸŒ Environment:', \"development\");\nconsole.log('ðŸ“ Next Public API URL:', \"http://localhost:3000/api/v1\");\n// Configurar instancia de axios\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: 60000,\n    headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    },\n    withCredentials: false\n});\n// Interceptor para debug de requests\napiClient.interceptors.request.use((config)=>{\n    var _config_method;\n    console.log('ðŸ” Request Debug:');\n    console.log('ðŸ“ URL:', config.url);\n    console.log('ðŸŒ Base URL:', config.baseURL);\n    console.log('ðŸŽ¯ Full URL:', \"\".concat(config.baseURL).concat(config.url));\n    console.log('ðŸ“ Method:', (_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase());\n    return config;\n}, (error)=>{\n    console.error('âŒ Request Error:', error);\n    return Promise.reject(error);\n});\n// Interceptor para debug de responses\napiClient.interceptors.response.use((response)=>{\n    console.log('âœ… Response Success:', response.status, response.config.url);\n    return response;\n}, (error)=>{\n    var _error_config, _error_config1, _error_config2, _error_config3, _error_response, _error_response1;\n    console.error('âŒ Response Error:');\n    console.error('ðŸ“ URL:', (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url);\n    console.error('ðŸŒ Base URL:', (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.baseURL);\n    console.error('ðŸŽ¯ Full URL:', \"\".concat((_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL).concat((_error_config3 = error.config) === null || _error_config3 === void 0 ? void 0 : _error_config3.url));\n    console.error('ðŸ“Š Status:', (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status);\n    console.error('ðŸ“„ Response:', (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data);\n    return Promise.reject(error);\n});\n// Utilidad para obtener el progreso del backend (simplificada para Node.js backend)\nfunction getProgress(batchStatus) {\n    // El nuevo backend ya proporciona toda la informaciÃ³n de progreso estructurada\n    return {\n        completed: batchStatus.progress.completed,\n        total: batchStatus.progress.total,\n        percentage: batchStatus.progress.percentage\n    };\n}\n// Servicios API\nclass ApiService {\n    /**\r\n   * Sube un archivo CSV al backend para procesamiento\r\n   * @param file - Archivo CSV a procesar\r\n   * @returns Respuesta con el batchId\r\n   */ static async uploadFile(file) {\n        const formData = new FormData();\n        formData.append('file', file);\n        try {\n            console.log('ðŸš€ Starting file upload:');\n            console.log('ðŸ“„ File:', file.name, 'Size:', file.size, 'Type:', file.type);\n            console.log('ðŸŒ Using proxy endpoint: /api/v1/scraping-batch');\n            const response = await fetch('/api/v1/scraping-batch', {\n                method: 'POST',\n                body: formData\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Upload failed:', response.status, errorText);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log('Upload successful:', data);\n            return data;\n        } catch (error) {\n            var _error_response, _error_response1, _error_response2, _error_response3, _error_response4, _error_message, _error_message1, _error_message2;\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('Upload error details:', {\n                message: error.message,\n                code: error.code,\n                status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n            });\n            // Manejo especÃ­fico de errores\n            if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n                throw new Error('âŒ Backend server is not running on port 3000. Please start your backend server with: docker-compose up --build -d');\n            } else if (error.code === 'ECONNABORTED') {\n                throw new Error('â±ï¸ Upload timeout - file too large or connection slow');\n            } else if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) === 413) {\n                throw new Error('ðŸ“¦ File too large');\n            } else if (((_error_response4 = error.response) === null || _error_response4 === void 0 ? void 0 : _error_response4.status) === 415) {\n                throw new Error('ðŸ“„ Invalid file type - only CSV files are allowed');\n            } else if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('HTTP 404')) {\n                throw new Error('ðŸ” Backend endpoint not found. Make sure backend is running and accessible.');\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('CORS')) {\n                throw new Error('ðŸŒ CORS Error: Backend needs CORS configuration. The backend is running but blocking browser requests.');\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes('Failed to fetch')) {\n                throw new Error('ðŸ”’ Connection blocked - possible CORS issue. Backend is running but not accessible from browser.');\n            } else {\n                throw new Error(\"\\uD83D\\uDEAB Upload failed: \".concat(error.message));\n            }\n        }\n    }\n    /**\r\n   * Obtiene el estado actual de un batch de procesamiento\r\n   * @param batchId - ID del batch a consultar\r\n   * @returns Estado actual del batch\r\n   */ static async getBatchStatus(batchId) {\n        try {\n            const response = await fetch(\"/api/v1/scraping-batch/\".concat(batchId), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    throw new Error('â“ Batch not found. It may have expired or been processed.');\n                }\n                throw new Error(\"HTTP \".concat(response.status, \": Failed to fetch batch status\"));\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('Error fetching batch status:', error);\n            throw new Error(\"Failed to fetch batch status: \".concat(error.message));\n        }\n    }\n    /**\r\n   * ðŸ†• Exporta y descarga CSV limpio desde el backend\r\n   * @param batchId - ID del batch a exportar\r\n   * @returns void - Inicia descarga automÃ¡tica del archivo\r\n   */ static async exportCleanCSV(batchId) {\n        try {\n            console.log('ðŸŽ¯ Starting CSV export for batch:', batchId);\n            const response = await apiClient.get(\"/scraping-batch/\".concat(batchId, \"/export\"), {\n                responseType: 'blob',\n                headers: {\n                    'Accept': 'text/csv'\n                },\n                timeout: 60000\n            });\n            // Crear un blob y generar descarga automÃ¡tica\n            const blob = new Blob([\n                response.data\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const url = window.URL.createObjectURL(blob);\n            // Crear elemento de descarga temporal\n            const link = document.createElement('a');\n            link.href = url;\n            // Generar nombre de archivo con timestamp\n            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n            link.download = \"scraping-results-\".concat(timestamp, \".csv\");\n            // Agregar al DOM temporalmente y hacer click\n            document.body.appendChild(link);\n            link.click();\n            // Limpiar\n            document.body.removeChild(link);\n            window.URL.revokeObjectURL(url);\n            console.log('âœ… CSV exported successfully');\n        } catch (error) {\n            var _error_response, _error_response1;\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('CSV export error:', error);\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404) {\n                throw new Error('â“ Batch not found or expired');\n            } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 400) {\n                throw new Error('ðŸš« Batch not ready for export yet');\n            } else {\n                var _error_response_data, _error_response2;\n                throw new Error(\"\\uD83D\\uDEAB Export failed: \".concat(((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data = _error_response2.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message));\n            }\n        }\n    }\n    /**\r\n   * ðŸ†• Valida el formato y contenido del archivo CSV\r\n   * @param file - Archivo CSV a validar\r\n   * @param t - FunciÃ³n de traducciÃ³n (opcional)\r\n   * @returns Resultado de la validaciÃ³n\r\n   */ static async validateCSV(file, t) {\n        return new Promise((resolve)=>{\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                var _e_target;\n                const text = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result;\n                const lines = text.split('\\n').filter((line)=>line.trim());\n                if (lines.length === 0) {\n                    resolve({\n                        isValid: false,\n                        errors: [\n                            t ? t('csv.file_empty') : 'File is empty'\n                        ],\n                        warnings: [],\n                        rowCount: 0,\n                        columns: [],\n                        requiredColumns: [\n                            'name',\n                            'address',\n                            'city'\n                        ],\n                        missingColumns: [\n                            'name',\n                            'address',\n                            'city'\n                        ]\n                    });\n                    return;\n                }\n                // Parse header\n                const header = lines[0].split(',').map((col)=>col.trim().replace(/[\"']/g, ''));\n                const requiredColumns = [\n                    'name',\n                    'address',\n                    'city'\n                ];\n                const optionalColumns = [\n                    'postal_code'\n                ];\n                const allValidColumns = [\n                    ...requiredColumns,\n                    ...optionalColumns\n                ];\n                // Validaciones\n                const errors = [];\n                const warnings = [];\n                const missingColumns = requiredColumns.filter((col)=>!header.some((h)=>h.toLowerCase().includes(col.toLowerCase())));\n                // Validar columnas requeridas\n                if (missingColumns.length > 0) {\n                    errors.push(t ? t('csv.required_columns_missing', {\n                        columns: missingColumns.join(', ')\n                    }) : \"Missing required columns: \".concat(missingColumns.join(', ')));\n                }\n                // Validar nÃºmero mÃ­nimo de filas\n                if (lines.length < 2) {\n                    errors.push(t ? t('csv.minimum_rows_required') : 'CSV must have at least one data row besides the header');\n                }\n                // Validar nÃºmero mÃ¡ximo de filas (lÃ­mite recomendado)\n                if (lines.length > 1001) {\n                    warnings.push(t ? t('csv.maximum_rows_warning', {\n                        count: lines.length - 1\n                    }) : \"File has \".concat(lines.length - 1, \" rows. Maximum 1000 recommended for better performance\"));\n                }\n                // Validar formato de datos (muestra de las primeras 5 filas)\n                const sampleRows = lines.slice(1, 6);\n                sampleRows.forEach((row, index)=>{\n                    const cells = row.split(',');\n                    if (cells.length !== header.length) {\n                        errors.push(t ? t('csv.column_mismatch', {\n                            row: index + 2,\n                            actual: cells.length,\n                            expected: header.length\n                        }) : \"Row \".concat(index + 2, \": Number of columns does not match header (\").concat(cells.length, \" vs \").concat(header.length, \")\"));\n                    }\n                    // Validar que el nombre no estÃ© vacÃ­o\n                    const nameIndex = header.findIndex((h)=>h.toLowerCase().includes('name'));\n                    if (nameIndex >= 0 && (!cells[nameIndex] || cells[nameIndex].trim().replace(/[\"']/g, '') === '')) {\n                        errors.push(t ? t('csv.empty_business_name', {\n                            row: index + 2\n                        }) : \"Row \".concat(index + 2, \": Business name cannot be empty\"));\n                    }\n                });\n                resolve({\n                    isValid: errors.length === 0,\n                    errors,\n                    warnings,\n                    rowCount: lines.length - 1,\n                    columns: header,\n                    requiredColumns,\n                    missingColumns\n                });\n            };\n            reader.onerror = ()=>{\n                resolve({\n                    isValid: false,\n                    errors: [\n                        t ? t('csv.file_read_error') : 'Error reading file'\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columns: [],\n                    requiredColumns: [\n                        'name',\n                        'address',\n                        'city'\n                    ],\n                    missingColumns: [\n                        'name',\n                        'address',\n                        'city'\n                    ]\n                });\n            };\n            reader.readAsText(file);\n        });\n    }\n    /**\r\n   * ðŸ†• Genera y descarga una plantilla CSV de ejemplo\r\n   * @returns void - Inicia descarga del archivo plantilla\r\n   */ static downloadCSVTemplate() {\n        const template = [\n            'name,address,city,postal_code',\n            'McDonald\\'s Bahnhofstrasse,\"Bahnhofstrasse 120\",ZÃ¼rich,8001',\n            'Starbucks Paradeplatz,\"Paradeplatz 4\",ZÃ¼rich,8001',\n            'Burger King Limmatquai,\"Limmatquai 66\",ZÃ¼rich,8001'\n        ].join('\\n');\n        const blob = new Blob([\n            template\n        ], {\n            type: 'text/csv;charset=utf-8;'\n        });\n        const url = window.URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'plantilla-scraping.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url);\n        console.log('âœ… Plantilla CSV descargada');\n    }\n    /**\r\n   * ðŸ†• Verifica el estado real de todos los servicios del backend\r\n   * @returns Estado detallado de cada servicio\r\n   */ static async checkServicesStatus() {\n        const result = {\n            api: {\n                status: 'unhealthy',\n                service: 'api'\n            },\n            redis: {\n                status: 'unhealthy',\n                service: 'redis'\n            },\n            worker: {\n                status: 'unhealthy',\n                service: 'worker'\n            },\n            lastCheck: new Date().toISOString(),\n            error: undefined\n        };\n        try {\n            // 1. Verificar API general (puerto 3000)  \n            const startTime = Date.now();\n            const apiResponse = await fetch('/api/v1/health', {\n                method: 'GET',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (apiResponse.ok) {\n                const apiData = await apiResponse.json();\n                result.api = {\n                    status: 'healthy',\n                    service: 'api',\n                    responseTime: \"\".concat(Date.now() - startTime, \"ms\"),\n                    details: apiData\n                };\n                // 2. Verificar Redis a travÃ©s de endpoint especÃ­fico\n                try {\n                    const redisResponse = await fetch('/api/v1/health/redis', {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/json',\n                            'Content-Type': 'application/json'\n                        }\n                    });\n                    if (redisResponse.ok) {\n                        const redisData = await redisResponse.json();\n                        result.redis = {\n                            status: redisData.status,\n                            service: 'redis',\n                            responseTime: redisData.responseTime,\n                            details: redisData\n                        };\n                    } else {\n                        result.redis = {\n                            status: 'unhealthy',\n                            service: 'redis',\n                            reason: \"HTTP \".concat(redisResponse.status)\n                        };\n                    }\n                } catch (error) {\n                    result.redis = {\n                        status: 'unhealthy',\n                        service: 'redis',\n                        reason: 'Connection failed'\n                    };\n                }\n                // 3. Verificar Worker a travÃ©s de endpoint especÃ­fico\n                try {\n                    const workerResponse = await fetch('/api/v1/health/worker', {\n                        method: 'GET',\n                        headers: {\n                            'Accept': 'application/json',\n                            'Content-Type': 'application/json'\n                        }\n                    });\n                    if (workerResponse.ok) {\n                        const workerData = await workerResponse.json();\n                        result.worker = {\n                            status: workerData.status,\n                            service: 'worker',\n                            responseTime: workerData.responseTime,\n                            reason: workerData.reason,\n                            details: workerData\n                        };\n                    } else {\n                        result.worker = {\n                            status: 'unhealthy',\n                            service: 'worker',\n                            reason: \"HTTP \".concat(workerResponse.status)\n                        };\n                    }\n                } catch (error) {\n                    result.worker = {\n                        status: 'unhealthy',\n                        service: 'worker',\n                        reason: 'Connection failed'\n                    };\n                }\n            } else {\n                result.api = {\n                    status: 'unhealthy',\n                    service: 'api',\n                    reason: \"HTTP \".concat(apiResponse.status),\n                    responseTime: \"\".concat(Date.now() - startTime, \"ms\")\n                };\n            }\n        } catch (error) {\n            result.error = error.message;\n            result.api = {\n                status: 'unhealthy',\n                service: 'api',\n                reason: error.message\n            };\n            console.error('Error checking services:', error);\n        }\n        return result;\n    }\n    /**\r\n   * Verifica si el backend estÃ¡ disponible\r\n   * @returns true si el backend responde\r\n   */ static async healthCheck() {\n        try {\n            var _response_data;\n            // Usar proxy de Next.js en desarrollo, directo en producciÃ³n\n            const healthUrl =  false ? 0 : '/health';\n            const healthClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n                timeout: 5000\n            });\n            // Usar endpoint /health segÃºn documentaciÃ³n del nuevo backend\n            const response = await healthClient.get(healthUrl);\n            console.log('âœ… Backend health check successful:', response.status, response.data);\n            return ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.status) === 'ok';\n        } catch (error) {\n            console.log('ðŸ”´ Backend health check failed');\n            console.log('Error details:', error.message);\n            return false;\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NEJBQTRCQTtRQUM1QztRQUVBLE9BQU9nRTtJQUNUO0lBRUE7OztHQUdDLEdBQ0QsYUFBYXdELGNBQWdDO1FBQzNDLElBQUk7Z0JBYUtySDtZQVpQLDZEQUE2RDtZQUM3RCxNQUFNc0gsWUFBWTNJLE1BQXFDLEdBQ25ELENBQThCLEdBQzlCO1lBRUosTUFBTTRJLGVBQWUvSSw2Q0FBS0EsQ0FBQ1MsTUFBTSxDQUFDO2dCQUNoQ0UsU0FBUztZQUNYO1lBRUEsOERBQThEO1lBQzlELE1BQU1hLFdBQVcsTUFBTXVILGFBQWF2RixHQUFHLENBQUNzRjtZQUN4Q3hJLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NpQixTQUFTQyxNQUFNLEVBQUVELFNBQVNFLElBQUk7WUFDaEYsT0FBT0YsRUFBQUEsaUJBQUFBLFNBQVNFLElBQUksY0FBYkYscUNBQUFBLGVBQWVDLE1BQU0sTUFBSztRQUNuQyxFQUFFLE9BQU9KLE9BQVk7WUFDbkJmLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsa0JBQWtCYyxNQUFNNEIsT0FBTztZQUMzQyxPQUFPO1FBQ1Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGRpbGFuXFxEb2N1bWVudHNcXEdpdEh1YlxcV2ViLVNjcmFwcGluZy1Gcm9udGVuZFxcc3JjXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NJbnN0YW5jZSwgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJ1xyXG5pbXBvcnQgeyBzaWxlbnRMb2csIHNpbGVudEVycm9yIH0gZnJvbSAnLi9kZWJ1ZydcclxuaW1wb3J0IHsgVHJhbnNsYXRpb25LZXkgfSBmcm9tICdAL2hvb2tzL3VzZS10cmFuc2xhdGlvbidcclxuXHJcbi8vIEJhc2UgVVJMIGRlbCBiYWNrZW5kIC0gdXNhciBwcm94eSBkZSBOZXh0LmpzIGVuIGRlc2Fycm9sbG8gcGFyYSBldml0YXIgQ09SU1xyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIFxyXG4gID8gKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvdjEnKVxyXG4gIDogJy9hcGkvdjEnIC8vIFVzYXIgcHJveHkgZGUgTmV4dC5qcyBlbiBkZXNhcnJvbGxvXHJcblxyXG5jb25zb2xlLmxvZygn8J+UpyBBUEkgQ29uZmlndXJhdGlvbjonKVxyXG5jb25zb2xlLmxvZygn8J+TjSBCYXNlIFVSTDonLCBBUElfQkFTRV9VUkwpXHJcbmNvbnNvbGUubG9nKCfwn4yNIEVudmlyb25tZW50OicsIHByb2Nlc3MuZW52Lk5PREVfRU5WKVxyXG5jb25zb2xlLmxvZygn8J+TnSBOZXh0IFB1YmxpYyBBUEkgVVJMOicsIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwpXHJcblxyXG4vLyBDb25maWd1cmFyIGluc3RhbmNpYSBkZSBheGlvc1xyXG5jb25zdCBhcGlDbGllbnQgPSBheGlvcy5jcmVhdGUoe1xyXG4gIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcclxuICB0aW1lb3V0OiA2MDAwMCwgLy8gNjAgc2VndW5kb3MgcGFyYSB1cGxvYWRzIGdyYW5kZXNcclxuICBoZWFkZXJzOiB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICB9LFxyXG4gIHdpdGhDcmVkZW50aWFsczogZmFsc2UsIC8vIFBhcmEgZXZpdGFyIHByb2JsZW1hcyBkZSBDT1JTXHJcbn0pXHJcblxyXG4vLyBJbnRlcmNlcHRvciBwYXJhIGRlYnVnIGRlIHJlcXVlc3RzXHJcbmFwaUNsaWVudC5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgKGNvbmZpZykgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gUmVxdWVzdCBEZWJ1ZzonKVxyXG4gICAgY29uc29sZS5sb2coJ/Cfk40gVVJMOicsIGNvbmZpZy51cmwpXHJcbiAgICBjb25zb2xlLmxvZygn8J+MkCBCYXNlIFVSTDonLCBjb25maWcuYmFzZVVSTClcclxuICAgIGNvbnNvbGUubG9nKCfwn46vIEZ1bGwgVVJMOicsIGAke2NvbmZpZy5iYXNlVVJMfSR7Y29uZmlnLnVybH1gKVxyXG4gICAgY29uc29sZS5sb2coJ/Cfk50gTWV0aG9kOicsIGNvbmZpZy5tZXRob2Q/LnRvVXBwZXJDYXNlKCkpXHJcbiAgICByZXR1cm4gY29uZmlnXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBSZXF1ZXN0IEVycm9yOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4gIH1cclxuKVxyXG5cclxuLy8gSW50ZXJjZXB0b3IgcGFyYSBkZWJ1ZyBkZSByZXNwb25zZXNcclxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXHJcbiAgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn4pyFIFJlc3BvbnNlIFN1Y2Nlc3M6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5jb25maWcudXJsKVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBSZXNwb25zZSBFcnJvcjonKVxyXG4gICAgY29uc29sZS5lcnJvcign8J+TjSBVUkw6JywgZXJyb3IuY29uZmlnPy51cmwpXHJcbiAgICBjb25zb2xlLmVycm9yKCfwn4yQIEJhc2UgVVJMOicsIGVycm9yLmNvbmZpZz8uYmFzZVVSTClcclxuICAgIGNvbnNvbGUuZXJyb3IoJ/Cfjq8gRnVsbCBVUkw6JywgYCR7ZXJyb3IuY29uZmlnPy5iYXNlVVJMfSR7ZXJyb3IuY29uZmlnPy51cmx9YClcclxuICAgIGNvbnNvbGUuZXJyb3IoJ/Cfk4ogU3RhdHVzOicsIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMpXHJcbiAgICBjb25zb2xlLmVycm9yKCfwn5OEIFJlc3BvbnNlOicsIGVycm9yLnJlc3BvbnNlPy5kYXRhKVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4gIH1cclxuKVxyXG5cclxuLy8gSW50ZXJmYWNlcyBwYXJhIGxhcyByZXNwdWVzdGFzIGRlbCBiYWNrZW5kXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hVcGxvYWRSZXNwb25zZSB7XHJcbiAgYmF0Y2hJZDogc3RyaW5nXHJcbiAgam9ic0NyZWF0ZWQ6IG51bWJlclxyXG4gIG1lc3NhZ2U6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoU3RhdHVzIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBzdGF0dXM6ICdxdWV1ZWQnIHwgJ3Byb2Nlc3NpbmcnIHwgJ2NvbXBsZXRlZCcgfCAnY29tcGxldGVkX3dpdGhfZXJyb3JzJ1xyXG4gIHByb2dyZXNzOiB7XHJcbiAgICB0b3RhbDogbnVtYmVyXHJcbiAgICBjb21wbGV0ZWQ6IG51bWJlclxyXG4gICAgZmFpbGVkOiBudW1iZXJcclxuICAgIHByb2Nlc3Npbmc6IG51bWJlclxyXG4gICAgd2FpdGluZzogbnVtYmVyXHJcbiAgICBwZXJjZW50YWdlOiBudW1iZXJcclxuICB9XHJcbiAgdGltaW5nOiB7XHJcbiAgICBjcmVhdGVkQXQ6IHN0cmluZ1xyXG4gICAgbGFzdFByb2Nlc3NlZEF0OiBzdHJpbmdcclxuICAgIGVzdGltYXRlZFRpbWVSZW1haW5pbmc6IHN0cmluZyB8IG51bGxcclxuICB9XHJcbiAgcmVzdWx0czogU2NyYXBpbmdSZXN1bHRbXVxyXG4gIHN1bW1hcnk6IHtcclxuICAgIHRvdGFsQnVzaW5lc3NlczogbnVtYmVyXHJcbiAgICBzdWNjZXNzZnVsU2NyYXBlczogbnVtYmVyXHJcbiAgICBwYXJ0aWFsU2NyYXBlczogbnVtYmVyXHJcbiAgICBmYWlsZWRTY3JhcGVzOiBudW1iZXJcclxuICB9XHJcbn1cclxuXHJcbi8vIEludGVyZmFjZSBmb3Igc3VjY2Vzc2Z1bCBzY3JhcGluZyByZXN1bHRzIChVcGRhdGVkIGZvciBOb2RlLmpzIGJhY2tlbmQpXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2NyYXBpbmdSZXN1bHQge1xyXG4gIGpvYklkOiBzdHJpbmdcclxuICBcclxuICAvLyBJTlBVVCBEQVRBIC0gT3JpZ2luYWwgZGF0YSBmcm9tIENTViBmaWxlXHJcbiAgb3JpZ2luYWxEYXRhOiB7XHJcbiAgICBuYW1lOiBzdHJpbmdcclxuICAgIGFkZHJlc3M/OiBzdHJpbmdcclxuICAgIGNpdHk/OiBzdHJpbmdcclxuICAgIHBvc3RhbF9jb2RlPzogc3RyaW5nXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFNDUkFQRUQgREFUQSAtIFJlYWwgZGF0YSBmb3VuZCBvbiBHb29nbGUgTWFwcyAoVXBkYXRlZCB3aXRoIG5ldyBmaWVsZHMpXHJcbiAgc2NyYXBlZERhdGE6IHtcclxuICAgIGZ1bGxOYW1lPzogc3RyaW5nXHJcbiAgICBmdWxsQWRkcmVzcz86IHN0cmluZ1xyXG4gICAgcGhvbmU/OiBzdHJpbmcgfCBudWxsXHJcbiAgICByYXRpbmc/OiBzdHJpbmcgfCBudWxsICAgICAgICAgICAgICAgICAgICAvLyDirZAgTkVXOiBSYXRpbmcvQ2FsaWZpY2FjacOzblxyXG4gICAgcmV2aWV3c0NvdW50Pzogc3RyaW5nIHwgbnVsbCAgICAgICAgICAgICAgLy8g8J+TiiBORVc6IE7Dum1lcm8gZGUgcmVzZcOxYXNcclxuICAgIHdlYnNpdGU/OiBzdHJpbmcgfCBudWxsICAgICAgICAgICAgICAgICAgIC8vIPCfjJAgTkVXOiBTaXRpbyB3ZWIgb2ZpY2lhbFxyXG4gICAgY2F0ZWdvcnk/OiBzdHJpbmcgfCBudWxsICAgICAgICAgICAgICAgICAgLy8g8J+Pt++4jyBORVc6IENhdGVnb3LDrWEvdGlwbyBkZSBuZWdvY2lvXHJcbiAgICBsYXRpdHVkZT86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgICAgICAvLyDwn5ONIE5FVzogR1BTIExhdGl0dWRlIGNvb3JkaW5hdGVcclxuICAgIGxvbmdpdHVkZT86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgICAgIC8vIPCfk40gTkVXOiBHUFMgTG9uZ2l0dWRlIGNvb3JkaW5hdGVcclxuICAgIHNvY2lhbE1lZGlhPzoge1xyXG4gICAgICBmYWNlYm9vaz86IHN0cmluZyB8IG51bGxcclxuICAgICAgaW5zdGFncmFtPzogc3RyaW5nIHwgbnVsbFxyXG4gICAgICB0d2l0dGVyPzogc3RyaW5nIHwgbnVsbFxyXG4gICAgICBsaW5rZWRpbj86IHN0cmluZyB8IG51bGxcclxuICAgICAgeW91dHViZT86IHN0cmluZyB8IG51bGxcclxuICAgIH1cclxuICAgIG9wZW5pbmdIb3Vycz86IHtcclxuICAgICAgW2RheTogc3RyaW5nXTogc3RyaW5nXHJcbiAgICB9XHJcbiAgICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdwYXJ0aWFsJyB8ICdmYWlsZWQnXHJcbiAgICBzY3JhcGVkQXQ6IHN0cmluZ1xyXG4gICAgZXJyb3I/OiBzdHJpbmcgfCBudWxsXHJcbiAgfSB8IG51bGxcclxuICBcclxuICAvLyBQUk9DRVNTSU5HIElORk9cclxuICBwcm9jZXNzaW5nVGltZTogbnVtYmVyXHJcbiAgcHJvY2Vzc2VkQXQ6IHN0cmluZ1xyXG4gIHdvcmtlcj86IG51bWJlclxyXG4gIGVycm9yPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3NIb3VycyB7XHJcbiAgbW9uZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgdHVlc2RheTogc3RyaW5nIHwgbnVsbFxyXG4gIHdlZG5lc2RheTogc3RyaW5nIHwgbnVsbFxyXG4gIHRodXJzZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgZnJpZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgc2F0dXJkYXk6IHN0cmluZyB8IG51bGxcclxuICBzdW5kYXk6IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuLy8g8J+GlSBJbnRlcmZhY2VzIHBhcmEgdmFsaWRhY2lvbmVzIHkgZXN0YWRvIGRlIHNlcnZpY2lvc1xyXG5leHBvcnQgaW50ZXJmYWNlIFJlZGlzSGVhbHRoRGV0YWlscyB7XHJcbiAgc3RhdHVzOiBzdHJpbmdcclxuICBzZXJ2aWNlOiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IHN0cmluZ1xyXG4gIHJlc3BvbnNlVGltZTogc3RyaW5nXHJcbiAgY29ubmVjdGlvbjoge1xyXG4gICAgc3RhdHVzOiBzdHJpbmdcclxuICAgIHF1ZXVlX2FjY2Vzc2libGU6IGJvb2xlYW5cclxuICB9XHJcbiAgb3BlcmF0aW9uczoge1xyXG4gICAgcXVldWVfc3RhdHM6IHN0cmluZ1xyXG4gICAgam9iX2NyZWF0aW9uOiBzdHJpbmdcclxuICAgIGpvYl9yZW1vdmFsOiBzdHJpbmdcclxuICB9XHJcbiAgcXVldWVfc3RhdHM6IHtcclxuICAgIHdhaXRpbmc6IG51bWJlclxyXG4gICAgYWN0aXZlOiBudW1iZXJcclxuICAgIGNvbXBsZXRlZDogbnVtYmVyXHJcbiAgICBmYWlsZWQ6IG51bWJlclxyXG4gICAgcGF1c2VkOiBudW1iZXJcclxuICB9XHJcbiAgd2FpdGluZ19qb2JzOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXb3JrZXJIZWFsdGhEZXRhaWxzIHtcclxuICBzdGF0dXM6IHN0cmluZ1xyXG4gIHNlcnZpY2U6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nXHJcbiAgcmVzcG9uc2VUaW1lOiBzdHJpbmdcclxuICByZWFzb246IHN0cmluZ1xyXG4gIHF1ZXVlX3N0YXRpc3RpY3M6IHtcclxuICAgIHdhaXRpbmc6IG51bWJlclxyXG4gICAgYWN0aXZlOiBudW1iZXJcclxuICAgIGNvbXBsZXRlZDogbnVtYmVyXHJcbiAgICBmYWlsZWQ6IG51bWJlclxyXG4gICAgZGVsYXllZDogbnVtYmVyXHJcbiAgfVxyXG4gIGFjdGl2ZV9qb2JzOiB7XHJcbiAgICBjb3VudDogbnVtYmVyXHJcbiAgICBqb2JzOiBhbnlbXVxyXG4gIH1cclxuICByZWNlbnRfYWN0aXZpdHk6IHtcclxuICAgIGNvbXBsZXRlZF9sYXN0XzVtaW46IG51bWJlclxyXG4gICAgbGFzdF9jb21wbGV0ZWQ6IHtcclxuICAgICAgaWQ6IHN0cmluZ1xyXG4gICAgICBjb21wbGV0ZWRBdDogc3RyaW5nXHJcbiAgICAgIHByb2Nlc3NpbmdUaW1lOiBudW1iZXJcclxuICAgIH0gfCBudWxsXHJcbiAgICBsYXN0X2ZhaWxlZDogYW55IHwgbnVsbFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlSGVhbHRoIHtcclxuICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5J1xyXG4gIHNlcnZpY2U6IHN0cmluZ1xyXG4gIHJlc3BvbnNlVGltZT86IHN0cmluZ1xyXG4gIHJlYXNvbj86IHN0cmluZ1xyXG4gIGRldGFpbHM/OiBSZWRpc0hlYWx0aERldGFpbHMgfCBXb3JrZXJIZWFsdGhEZXRhaWxzIHwgYW55XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VydmljZVN0YXR1cyB7XHJcbiAgYXBpOiBTZXJ2aWNlSGVhbHRoXHJcbiAgcmVkaXM6IFNlcnZpY2VIZWFsdGhcclxuICB3b3JrZXI6IFNlcnZpY2VIZWFsdGhcclxuICBsYXN0Q2hlY2s6IHN0cmluZ1xyXG4gIGVycm9yPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ1NWVmFsaWRhdGlvblJlc3VsdCB7XHJcbiAgaXNWYWxpZDogYm9vbGVhblxyXG4gIGVycm9yczogc3RyaW5nW11cclxuICB3YXJuaW5nczogc3RyaW5nW11cclxuICByb3dDb3VudDogbnVtYmVyXHJcbiAgY29sdW1uczogc3RyaW5nW11cclxuICByZXF1aXJlZENvbHVtbnM6IHN0cmluZ1tdXHJcbiAgbWlzc2luZ0NvbHVtbnM6IHN0cmluZ1tdXHJcbn1cclxuXHJcbi8vIFV0aWxpZGFkIHBhcmEgb2J0ZW5lciBlbCBwcm9ncmVzbyBkZWwgYmFja2VuZCAoc2ltcGxpZmljYWRhIHBhcmEgTm9kZS5qcyBiYWNrZW5kKVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoYmF0Y2hTdGF0dXM6IEJhdGNoU3RhdHVzKTogeyBjb21wbGV0ZWQ6IG51bWJlcjsgdG90YWw6IG51bWJlcjsgcGVyY2VudGFnZTogbnVtYmVyIH0ge1xyXG4gIC8vIEVsIG51ZXZvIGJhY2tlbmQgeWEgcHJvcG9yY2lvbmEgdG9kYSBsYSBpbmZvcm1hY2nDs24gZGUgcHJvZ3Jlc28gZXN0cnVjdHVyYWRhXHJcbiAgcmV0dXJuIHtcclxuICAgIGNvbXBsZXRlZDogYmF0Y2hTdGF0dXMucHJvZ3Jlc3MuY29tcGxldGVkLFxyXG4gICAgdG90YWw6IGJhdGNoU3RhdHVzLnByb2dyZXNzLnRvdGFsLFxyXG4gICAgcGVyY2VudGFnZTogYmF0Y2hTdGF0dXMucHJvZ3Jlc3MucGVyY2VudGFnZVxyXG4gIH1cclxufVxyXG5cclxuLy8gU2VydmljaW9zIEFQSVxyXG5leHBvcnQgY2xhc3MgQXBpU2VydmljZSB7XHJcbiAgLyoqXHJcbiAgICogU3ViZSB1biBhcmNoaXZvIENTViBhbCBiYWNrZW5kIHBhcmEgcHJvY2VzYW1pZW50b1xyXG4gICAqIEBwYXJhbSBmaWxlIC0gQXJjaGl2byBDU1YgYSBwcm9jZXNhclxyXG4gICAqIEByZXR1cm5zIFJlc3B1ZXN0YSBjb24gZWwgYmF0Y2hJZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyB1cGxvYWRGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPEJhdGNoVXBsb2FkUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcclxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpXHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5qAIFN0YXJ0aW5nIGZpbGUgdXBsb2FkOicpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OEIEZpbGU6JywgZmlsZS5uYW1lLCAnU2l6ZTonLCBmaWxlLnNpemUsICdUeXBlOicsIGZpbGUudHlwZSlcclxuICAgICAgY29uc29sZS5sb2coJ/CfjJAgVXNpbmcgcHJveHkgZW5kcG9pbnQ6IC9hcGkvdjEvc2NyYXBpbmctYmF0Y2gnKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92MS9zY3JhcGluZy1iYXRjaCcsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdVcGxvYWQgZmFpbGVkOicsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhdGE6IEJhdGNoVXBsb2FkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgY29uc29sZS5sb2coJ1VwbG9hZCBzdWNjZXNzZnVsOicsIGRhdGEpXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHNpbGVudEVycm9yKCdVcGxvYWQgZXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxyXG4gICAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2U/LnN0YXR1cyxcclxuICAgICAgICBzdGF0dXNUZXh0OiBlcnJvci5yZXNwb25zZT8uc3RhdHVzVGV4dCxcclxuICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZT8uZGF0YVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gTWFuZWpvIGVzcGVjw61maWNvIGRlIGVycm9yZXNcclxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnIHx8IGVycm9yLmNvZGUgPT09ICdFTk9URk9VTkQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfinYwgQmFja2VuZCBzZXJ2ZXIgaXMgbm90IHJ1bm5pbmcgb24gcG9ydCAzMDAwLiBQbGVhc2Ugc3RhcnQgeW91ciBiYWNrZW5kIHNlcnZlciB3aXRoOiBkb2NrZXItY29tcG9zZSB1cCAtLWJ1aWxkIC1kJylcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign4o+x77iPIFVwbG9hZCB0aW1lb3V0IC0gZmlsZSB0b28gbGFyZ2Ugb3IgY29ubmVjdGlvbiBzbG93JylcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MTMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/Cfk6YgRmlsZSB0b28gbGFyZ2UnKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQxNSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign8J+ThCBJbnZhbGlkIGZpbGUgdHlwZSAtIG9ubHkgQ1NWIGZpbGVzIGFyZSBhbGxvd2VkJylcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnSFRUUCA0MDQnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign8J+UjSBCYWNrZW5kIGVuZHBvaW50IG5vdCBmb3VuZC4gTWFrZSBzdXJlIGJhY2tlbmQgaXMgcnVubmluZyBhbmQgYWNjZXNzaWJsZS4nKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdDT1JTJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/CfjJAgQ09SUyBFcnJvcjogQmFja2VuZCBuZWVkcyBDT1JTIGNvbmZpZ3VyYXRpb24uIFRoZSBiYWNrZW5kIGlzIHJ1bm5pbmcgYnV0IGJsb2NraW5nIGJyb3dzZXIgcmVxdWVzdHMuJylcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/CflJIgQ29ubmVjdGlvbiBibG9ja2VkIC0gcG9zc2libGUgQ09SUyBpc3N1ZS4gQmFja2VuZCBpcyBydW5uaW5nIGJ1dCBub3QgYWNjZXNzaWJsZSBmcm9tIGJyb3dzZXIuJylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYPCfmqsgVXBsb2FkIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZWwgZXN0YWRvIGFjdHVhbCBkZSB1biBiYXRjaCBkZSBwcm9jZXNhbWllbnRvXHJcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBJRCBkZWwgYmF0Y2ggYSBjb25zdWx0YXJcclxuICAgKiBAcmV0dXJucyBFc3RhZG8gYWN0dWFsIGRlbCBiYXRjaFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBnZXRCYXRjaFN0YXR1cyhiYXRjaElkOiBzdHJpbmcpOiBQcm9taXNlPEJhdGNoU3RhdHVzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3YxL3NjcmFwaW5nLWJhdGNoLyR7YmF0Y2hJZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+KdkyBCYXRjaCBub3QgZm91bmQuIEl0IG1heSBoYXZlIGV4cGlyZWQgb3IgYmVlbiBwcm9jZXNzZWQuJylcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogRmFpbGVkIHRvIGZldGNoIGJhdGNoIHN0YXR1c2ApXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhdGE6IEJhdGNoU3RhdHVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgIHJldHVybiBkYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHNpbGVudEVycm9yKCdFcnJvciBmZXRjaGluZyBiYXRjaCBzdGF0dXM6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGJhdGNoIHN0YXR1czogJHtlcnJvci5tZXNzYWdlfWApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDwn4aVIEV4cG9ydGEgeSBkZXNjYXJnYSBDU1YgbGltcGlvIGRlc2RlIGVsIGJhY2tlbmRcclxuICAgKiBAcGFyYW0gYmF0Y2hJZCAtIElEIGRlbCBiYXRjaCBhIGV4cG9ydGFyXHJcbiAgICogQHJldHVybnMgdm9pZCAtIEluaWNpYSBkZXNjYXJnYSBhdXRvbcOhdGljYSBkZWwgYXJjaGl2b1xyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBleHBvcnRDbGVhbkNTVihiYXRjaElkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn46vIFN0YXJ0aW5nIENTViBleHBvcnQgZm9yIGJhdGNoOicsIGJhdGNoSWQpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9zY3JhcGluZy1iYXRjaC8ke2JhdGNoSWR9L2V4cG9ydGAsIHtcclxuICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJywgLy8gSW1wb3J0YW50ZSBwYXJhIGFyY2hpdm9zIGJpbmFyaW9zXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0FjY2VwdCc6ICd0ZXh0L2NzdicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW1lb3V0OiA2MDAwMCwgLy8gNjAgc2VndW5kb3MgcGFyYSBleHBvcnRhY2nDs25cclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIENyZWFyIHVuIGJsb2IgeSBnZW5lcmFyIGRlc2NhcmdhIGF1dG9tw6F0aWNhXHJcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbcmVzcG9uc2UuZGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7JyB9KVxyXG4gICAgICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXIgZWxlbWVudG8gZGUgZGVzY2FyZ2EgdGVtcG9yYWxcclxuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxyXG4gICAgICBsaW5rLmhyZWYgPSB1cmxcclxuICAgICAgXHJcbiAgICAgIC8vIEdlbmVyYXIgbm9tYnJlIGRlIGFyY2hpdm8gY29uIHRpbWVzdGFtcFxyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTkpLnJlcGxhY2UoLzovZywgJy0nKVxyXG4gICAgICBsaW5rLmRvd25sb2FkID0gYHNjcmFwaW5nLXJlc3VsdHMtJHt0aW1lc3RhbXB9LmNzdmBcclxuICAgICAgXHJcbiAgICAgIC8vIEFncmVnYXIgYWwgRE9NIHRlbXBvcmFsbWVudGUgeSBoYWNlciBjbGlja1xyXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXHJcbiAgICAgIGxpbmsuY2xpY2soKVxyXG4gICAgICBcclxuICAgICAgLy8gTGltcGlhclxyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspXHJcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQ1NWIGV4cG9ydGVkIHN1Y2Nlc3NmdWxseScpXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHNpbGVudEVycm9yKCdDU1YgZXhwb3J0IGVycm9yOicsIGVycm9yKVxyXG4gICAgICBcclxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign4p2TIEJhdGNoIG5vdCBmb3VuZCBvciBleHBpcmVkJylcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/CfmqsgQmF0Y2ggbm90IHJlYWR5IGZvciBleHBvcnQgeWV0JylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYPCfmqsgRXhwb3J0IGZhaWxlZDogJHtlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIPCfhpUgVmFsaWRhIGVsIGZvcm1hdG8geSBjb250ZW5pZG8gZGVsIGFyY2hpdm8gQ1NWXHJcbiAgICogQHBhcmFtIGZpbGUgLSBBcmNoaXZvIENTViBhIHZhbGlkYXJcclxuICAgKiBAcGFyYW0gdCAtIEZ1bmNpw7NuIGRlIHRyYWR1Y2Npw7NuIChvcGNpb25hbClcclxuICAgKiBAcmV0dXJucyBSZXN1bHRhZG8gZGUgbGEgdmFsaWRhY2nDs25cclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgdmFsaWRhdGVDU1YoZmlsZTogRmlsZSwgdD86IChrZXk6IFRyYW5zbGF0aW9uS2V5LCBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXI+KSA9PiBzdHJpbmcpOiBQcm9taXNlPENTVlZhbGlkYXRpb25SZXN1bHQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXHJcbiAgICAgIFxyXG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gZS50YXJnZXQ/LnJlc3VsdCBhcyBzdHJpbmdcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgICAgZXJyb3JzOiBbdCA/IHQoJ2Nzdi5maWxlX2VtcHR5JykgOiAnRmlsZSBpcyBlbXB0eSddLFxyXG4gICAgICAgICAgICB3YXJuaW5nczogW10sXHJcbiAgICAgICAgICAgIHJvd0NvdW50OiAwLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiBbXSxcclxuICAgICAgICAgICAgcmVxdWlyZWRDb2x1bW5zOiBbJ25hbWUnLCAnYWRkcmVzcycsICdjaXR5J10sXHJcbiAgICAgICAgICAgIG1pc3NpbmdDb2x1bW5zOiBbJ25hbWUnLCAnYWRkcmVzcycsICdjaXR5J11cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUGFyc2UgaGVhZGVyXHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbGluZXNbMF0uc3BsaXQoJywnKS5tYXAoY29sID0+IGNvbC50cmltKCkucmVwbGFjZSgvW1wiJ10vZywgJycpKVxyXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkQ29sdW1ucyA9IFsnbmFtZScsICdhZGRyZXNzJywgJ2NpdHknXVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsQ29sdW1ucyA9IFsncG9zdGFsX2NvZGUnXVxyXG4gICAgICAgIGNvbnN0IGFsbFZhbGlkQ29sdW1ucyA9IFsuLi5yZXF1aXJlZENvbHVtbnMsIC4uLm9wdGlvbmFsQ29sdW1uc11cclxuICAgICAgICBcclxuICAgICAgICAvLyBWYWxpZGFjaW9uZXNcclxuICAgICAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cclxuICAgICAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxyXG4gICAgICAgIGNvbnN0IG1pc3NpbmdDb2x1bW5zID0gcmVxdWlyZWRDb2x1bW5zLmZpbHRlcihjb2wgPT4gXHJcbiAgICAgICAgICAhaGVhZGVyLnNvbWUoaCA9PiBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoY29sLnRvTG93ZXJDYXNlKCkpKVxyXG4gICAgICAgIClcclxuICAgICAgICBcclxuICAgICAgICAvLyBWYWxpZGFyIGNvbHVtbmFzIHJlcXVlcmlkYXNcclxuICAgICAgICBpZiAobWlzc2luZ0NvbHVtbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgZXJyb3JzLnB1c2godCA/IHQoJ2Nzdi5yZXF1aXJlZF9jb2x1bW5zX21pc3NpbmcnLCB7IGNvbHVtbnM6IG1pc3NpbmdDb2x1bW5zLmpvaW4oJywgJykgfSkgOiBgTWlzc2luZyByZXF1aXJlZCBjb2x1bW5zOiAke21pc3NpbmdDb2x1bW5zLmpvaW4oJywgJyl9YClcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmFsaWRhciBuw7ptZXJvIG3DrW5pbW8gZGUgZmlsYXNcclxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgZXJyb3JzLnB1c2godCA/IHQoJ2Nzdi5taW5pbXVtX3Jvd3NfcmVxdWlyZWQnKSA6ICdDU1YgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBkYXRhIHJvdyBiZXNpZGVzIHRoZSBoZWFkZXInKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBWYWxpZGFyIG7Dum1lcm8gbcOheGltbyBkZSBmaWxhcyAobMOtbWl0ZSByZWNvbWVuZGFkbylcclxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMTAwMSkgeyAvLyAxMDAwICsgaGVhZGVyXHJcbiAgICAgICAgICB3YXJuaW5ncy5wdXNoKHQgPyB0KCdjc3YubWF4aW11bV9yb3dzX3dhcm5pbmcnLCB7IGNvdW50OiBsaW5lcy5sZW5ndGggLSAxIH0pIDogYEZpbGUgaGFzICR7bGluZXMubGVuZ3RoIC0gMX0gcm93cy4gTWF4aW11bSAxMDAwIHJlY29tbWVuZGVkIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBWYWxpZGFyIGZvcm1hdG8gZGUgZGF0b3MgKG11ZXN0cmEgZGUgbGFzIHByaW1lcmFzIDUgZmlsYXMpXHJcbiAgICAgICAgY29uc3Qgc2FtcGxlUm93cyA9IGxpbmVzLnNsaWNlKDEsIDYpXHJcbiAgICAgICAgc2FtcGxlUm93cy5mb3JFYWNoKChyb3csIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjZWxscyA9IHJvdy5zcGxpdCgnLCcpXHJcbiAgICAgICAgICBpZiAoY2VsbHMubGVuZ3RoICE9PSBoZWFkZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHQgPyB0KCdjc3YuY29sdW1uX21pc21hdGNoJywgeyByb3c6IGluZGV4ICsgMiwgYWN0dWFsOiBjZWxscy5sZW5ndGgsIGV4cGVjdGVkOiBoZWFkZXIubGVuZ3RoIH0pIDogYFJvdyAke2luZGV4ICsgMn06IE51bWJlciBvZiBjb2x1bW5zIGRvZXMgbm90IG1hdGNoIGhlYWRlciAoJHtjZWxscy5sZW5ndGh9IHZzICR7aGVhZGVyLmxlbmd0aH0pYClcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVmFsaWRhciBxdWUgZWwgbm9tYnJlIG5vIGVzdMOpIHZhY8Otb1xyXG4gICAgICAgICAgY29uc3QgbmFtZUluZGV4ID0gaGVhZGVyLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbmFtZScpKVxyXG4gICAgICAgICAgaWYgKG5hbWVJbmRleCA+PSAwICYmICghY2VsbHNbbmFtZUluZGV4XSB8fCBjZWxsc1tuYW1lSW5kZXhdLnRyaW0oKS5yZXBsYWNlKC9bXCInXS9nLCAnJykgPT09ICcnKSkge1xyXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0ID8gdCgnY3N2LmVtcHR5X2J1c2luZXNzX25hbWUnLCB7IHJvdzogaW5kZXggKyAyIH0pIDogYFJvdyAke2luZGV4ICsgMn06IEJ1c2luZXNzIG5hbWUgY2Fubm90IGJlIGVtcHR5YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcclxuICAgICAgICAgIGVycm9ycyxcclxuICAgICAgICAgIHdhcm5pbmdzLFxyXG4gICAgICAgICAgcm93Q291bnQ6IGxpbmVzLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICBjb2x1bW5zOiBoZWFkZXIsXHJcbiAgICAgICAgICByZXF1aXJlZENvbHVtbnMsXHJcbiAgICAgICAgICBtaXNzaW5nQ29sdW1uc1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJlYWRlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvcnM6IFt0ID8gdCgnY3N2LmZpbGVfcmVhZF9lcnJvcicpIDogJ0Vycm9yIHJlYWRpbmcgZmlsZSddLFxyXG4gICAgICAgICAgd2FybmluZ3M6IFtdLFxyXG4gICAgICAgICAgcm93Q291bnQ6IDAsXHJcbiAgICAgICAgICBjb2x1bW5zOiBbXSxcclxuICAgICAgICAgIHJlcXVpcmVkQ29sdW1uczogWyduYW1lJywgJ2FkZHJlc3MnLCAnY2l0eSddLFxyXG4gICAgICAgICAgbWlzc2luZ0NvbHVtbnM6IFsnbmFtZScsICdhZGRyZXNzJywgJ2NpdHknXVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog8J+GlSBHZW5lcmEgeSBkZXNjYXJnYSB1bmEgcGxhbnRpbGxhIENTViBkZSBlamVtcGxvXHJcbiAgICogQHJldHVybnMgdm9pZCAtIEluaWNpYSBkZXNjYXJnYSBkZWwgYXJjaGl2byBwbGFudGlsbGFcclxuICAgKi9cclxuICBzdGF0aWMgZG93bmxvYWRDU1ZUZW1wbGF0ZSgpOiB2b2lkIHtcclxuICAgIGNvbnN0IHRlbXBsYXRlID0gW1xyXG4gICAgICAnbmFtZSxhZGRyZXNzLGNpdHkscG9zdGFsX2NvZGUnLFxyXG4gICAgICAnTWNEb25hbGRcXCdzIEJhaG5ob2ZzdHJhc3NlLFwiQmFobmhvZnN0cmFzc2UgMTIwXCIsWsO8cmljaCw4MDAxJyxcclxuICAgICAgJ1N0YXJidWNrcyBQYXJhZGVwbGF0eixcIlBhcmFkZXBsYXR6IDRcIixaw7xyaWNoLDgwMDEnLFxyXG4gICAgICAnQnVyZ2VyIEtpbmcgTGltbWF0cXVhaSxcIkxpbW1hdHF1YWkgNjZcIixaw7xyaWNoLDgwMDEnXHJcbiAgICBdLmpvaW4oJ1xcbicpXHJcbiAgICBcclxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbdGVtcGxhdGVdLCB7IHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OycgfSlcclxuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXHJcbiAgICBcclxuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgIGxpbmsuaHJlZiA9IHVybFxyXG4gICAgbGluay5kb3dubG9hZCA9ICdwbGFudGlsbGEtc2NyYXBpbmcuY3N2J1xyXG4gICAgXHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXHJcbiAgICBsaW5rLmNsaWNrKClcclxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluaylcclxuICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybClcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ+KchSBQbGFudGlsbGEgQ1NWIGRlc2NhcmdhZGEnKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog8J+GlSBWZXJpZmljYSBlbCBlc3RhZG8gcmVhbCBkZSB0b2RvcyBsb3Mgc2VydmljaW9zIGRlbCBiYWNrZW5kXHJcbiAgICogQHJldHVybnMgRXN0YWRvIGRldGFsbGFkbyBkZSBjYWRhIHNlcnZpY2lvXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGNoZWNrU2VydmljZXNTdGF0dXMoKTogUHJvbWlzZTxTZXJ2aWNlU3RhdHVzPiB7XHJcbiAgICBjb25zdCByZXN1bHQ6IFNlcnZpY2VTdGF0dXMgPSB7XHJcbiAgICAgIGFwaToge1xyXG4gICAgICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXHJcbiAgICAgICAgc2VydmljZTogJ2FwaSdcclxuICAgICAgfSxcclxuICAgICAgcmVkaXM6IHtcclxuICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxyXG4gICAgICAgIHNlcnZpY2U6ICdyZWRpcydcclxuICAgICAgfSxcclxuICAgICAgd29ya2VyOiB7XHJcbiAgICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcclxuICAgICAgICBzZXJ2aWNlOiAnd29ya2VyJ1xyXG4gICAgICB9LFxyXG4gICAgICBsYXN0Q2hlY2s6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgZXJyb3I6IHVuZGVmaW5lZFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyAxLiBWZXJpZmljYXIgQVBJIGdlbmVyYWwgKHB1ZXJ0byAzMDAwKSAgXHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcclxuICAgICAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92MS9oZWFsdGgnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIGlmIChhcGlSZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGFwaURhdGEgPSBhd2FpdCBhcGlSZXNwb25zZS5qc29uKClcclxuICAgICAgICByZXN1bHQuYXBpID0ge1xyXG4gICAgICAgICAgc3RhdHVzOiAnaGVhbHRoeScsXHJcbiAgICAgICAgICBzZXJ2aWNlOiAnYXBpJyxcclxuICAgICAgICAgIHJlc3BvbnNlVGltZTogYCR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsXHJcbiAgICAgICAgICBkZXRhaWxzOiBhcGlEYXRhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIDIuIFZlcmlmaWNhciBSZWRpcyBhIHRyYXbDqXMgZGUgZW5kcG9pbnQgZXNwZWPDrWZpY29cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVkaXNSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3YxL2hlYWx0aC9yZWRpcycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocmVkaXNSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCByZWRpc0RhdGE6IFJlZGlzSGVhbHRoRGV0YWlscyA9IGF3YWl0IHJlZGlzUmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgICAgIHJlc3VsdC5yZWRpcyA9IHtcclxuICAgICAgICAgICAgICBzdGF0dXM6IHJlZGlzRGF0YS5zdGF0dXMgYXMgJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknLFxyXG4gICAgICAgICAgICAgIHNlcnZpY2U6ICdyZWRpcycsXHJcbiAgICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiByZWRpc0RhdGEucmVzcG9uc2VUaW1lLFxyXG4gICAgICAgICAgICAgIGRldGFpbHM6IHJlZGlzRGF0YVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucmVkaXMgPSB7XHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcclxuICAgICAgICAgICAgICBzZXJ2aWNlOiAncmVkaXMnLFxyXG4gICAgICAgICAgICAgIHJlYXNvbjogYEhUVFAgJHtyZWRpc1Jlc3BvbnNlLnN0YXR1c31gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0LnJlZGlzID0ge1xyXG4gICAgICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxyXG4gICAgICAgICAgICBzZXJ2aWNlOiAncmVkaXMnLFxyXG4gICAgICAgICAgICByZWFzb246ICdDb25uZWN0aW9uIGZhaWxlZCdcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gMy4gVmVyaWZpY2FyIFdvcmtlciBhIHRyYXbDqXMgZGUgZW5kcG9pbnQgZXNwZWPDrWZpY29cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qgd29ya2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS92MS9oZWFsdGgvd29ya2VyJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmICh3b3JrZXJSZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCB3b3JrZXJEYXRhOiBXb3JrZXJIZWFsdGhEZXRhaWxzID0gYXdhaXQgd29ya2VyUmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgICAgIHJlc3VsdC53b3JrZXIgPSB7XHJcbiAgICAgICAgICAgICAgc3RhdHVzOiB3b3JrZXJEYXRhLnN0YXR1cyBhcyAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeScsXHJcbiAgICAgICAgICAgICAgc2VydmljZTogJ3dvcmtlcicsXHJcbiAgICAgICAgICAgICAgcmVzcG9uc2VUaW1lOiB3b3JrZXJEYXRhLnJlc3BvbnNlVGltZSxcclxuICAgICAgICAgICAgICByZWFzb246IHdvcmtlckRhdGEucmVhc29uLFxyXG4gICAgICAgICAgICAgIGRldGFpbHM6IHdvcmtlckRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LndvcmtlciA9IHtcclxuICAgICAgICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxyXG4gICAgICAgICAgICAgIHNlcnZpY2U6ICd3b3JrZXInLFxyXG4gICAgICAgICAgICAgIHJlYXNvbjogYEhUVFAgJHt3b3JrZXJSZXNwb25zZS5zdGF0dXN9YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIHJlc3VsdC53b3JrZXIgPSB7XHJcbiAgICAgICAgICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXHJcbiAgICAgICAgICAgIHNlcnZpY2U6ICd3b3JrZXInLFxyXG4gICAgICAgICAgICByZWFzb246ICdDb25uZWN0aW9uIGZhaWxlZCdcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LmFwaSA9IHtcclxuICAgICAgICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXHJcbiAgICAgICAgICBzZXJ2aWNlOiAnYXBpJyxcclxuICAgICAgICAgIHJlYXNvbjogYEhUVFAgJHthcGlSZXNwb25zZS5zdGF0dXN9YCxcclxuICAgICAgICAgIHJlc3BvbnNlVGltZTogYCR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2BcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHJlc3VsdC5lcnJvciA9IGVycm9yLm1lc3NhZ2VcclxuICAgICAgcmVzdWx0LmFwaSA9IHtcclxuICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxyXG4gICAgICAgIHNlcnZpY2U6ICdhcGknLFxyXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHNlcnZpY2VzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWZXJpZmljYSBzaSBlbCBiYWNrZW5kIGVzdMOhIGRpc3BvbmlibGVcclxuICAgKiBAcmV0dXJucyB0cnVlIHNpIGVsIGJhY2tlbmQgcmVzcG9uZGVcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVc2FyIHByb3h5IGRlIE5leHQuanMgZW4gZGVzYXJyb2xsbywgZGlyZWN0byBlbiBwcm9kdWNjacOzblxyXG4gICAgICBjb25zdCBoZWFsdGhVcmwgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIFxyXG4gICAgICAgID8gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9oZWFsdGgnXHJcbiAgICAgICAgOiAnL2hlYWx0aCdcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGhlYWx0aENsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgICAgICAgdGltZW91dDogNTAwMCxcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIC8vIFVzYXIgZW5kcG9pbnQgL2hlYWx0aCBzZWfDum4gZG9jdW1lbnRhY2nDs24gZGVsIG51ZXZvIGJhY2tlbmRcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoZWFsdGhDbGllbnQuZ2V0KGhlYWx0aFVybClcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBCYWNrZW5kIGhlYWx0aCBjaGVjayBzdWNjZXNzZnVsOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuZGF0YSlcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE/LnN0YXR1cyA9PT0gJ29rJ1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UtCBCYWNrZW5kIGhlYWx0aCBjaGVjayBmYWlsZWQnKVxyXG4gICAgICBjb25zb2xlLmxvZygnRXJyb3IgZGV0YWlsczonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcbn0iXSwibmFtZXMiOlsiYXhpb3MiLCJzaWxlbnRFcnJvciIsIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiY29uc29sZSIsImxvZyIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsIndpdGhDcmVkZW50aWFscyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJ1cmwiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwic3RhdHVzIiwiZGF0YSIsImdldFByb2dyZXNzIiwiYmF0Y2hTdGF0dXMiLCJjb21wbGV0ZWQiLCJwcm9ncmVzcyIsInRvdGFsIiwicGVyY2VudGFnZSIsIkFwaVNlcnZpY2UiLCJ1cGxvYWRGaWxlIiwiZmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJuYW1lIiwic2l6ZSIsInR5cGUiLCJmZXRjaCIsImJvZHkiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJFcnJvciIsImpzb24iLCJtZXNzYWdlIiwiY29kZSIsInN0YXR1c1RleHQiLCJpbmNsdWRlcyIsImdldEJhdGNoU3RhdHVzIiwiYmF0Y2hJZCIsImV4cG9ydENsZWFuQ1NWIiwiZ2V0IiwicmVzcG9uc2VUeXBlIiwiYmxvYiIsIkJsb2IiLCJ3aW5kb3ciLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJsaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwicmVwbGFjZSIsImRvd25sb2FkIiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwicmV2b2tlT2JqZWN0VVJMIiwidmFsaWRhdGVDU1YiLCJ0IiwicmVzb2x2ZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwidGFyZ2V0IiwicmVzdWx0IiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiaXNWYWxpZCIsImVycm9ycyIsIndhcm5pbmdzIiwicm93Q291bnQiLCJjb2x1bW5zIiwicmVxdWlyZWRDb2x1bW5zIiwibWlzc2luZ0NvbHVtbnMiLCJoZWFkZXIiLCJtYXAiLCJjb2wiLCJvcHRpb25hbENvbHVtbnMiLCJhbGxWYWxpZENvbHVtbnMiLCJzb21lIiwiaCIsInRvTG93ZXJDYXNlIiwicHVzaCIsImpvaW4iLCJjb3VudCIsInNhbXBsZVJvd3MiLCJmb3JFYWNoIiwicm93IiwiaW5kZXgiLCJjZWxscyIsImFjdHVhbCIsImV4cGVjdGVkIiwibmFtZUluZGV4IiwiZmluZEluZGV4Iiwib25lcnJvciIsInJlYWRBc1RleHQiLCJkb3dubG9hZENTVlRlbXBsYXRlIiwidGVtcGxhdGUiLCJjaGVja1NlcnZpY2VzU3RhdHVzIiwiYXBpIiwic2VydmljZSIsInJlZGlzIiwid29ya2VyIiwibGFzdENoZWNrIiwidW5kZWZpbmVkIiwic3RhcnRUaW1lIiwibm93IiwiYXBpUmVzcG9uc2UiLCJhcGlEYXRhIiwicmVzcG9uc2VUaW1lIiwiZGV0YWlscyIsInJlZGlzUmVzcG9uc2UiLCJyZWRpc0RhdGEiLCJyZWFzb24iLCJ3b3JrZXJSZXNwb25zZSIsIndvcmtlckRhdGEiLCJoZWFsdGhDaGVjayIsImhlYWx0aFVybCIsImhlYWx0aENsaWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});