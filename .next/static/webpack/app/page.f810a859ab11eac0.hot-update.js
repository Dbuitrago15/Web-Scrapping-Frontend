"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiService: () => (/* binding */ ApiService),\n/* harmony export */   getProgress: () => (/* binding */ getProgress)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug */ \"(app-pages-browser)/./src/lib/debug.ts\");\n\n\n// Base URL del backend - usar proxy de Next.js en desarrollo para evitar CORS\nconst API_BASE_URL =  false ? 0 : '/api/v1' // Usar proxy de Next.js en desarrollo\n;\nconsole.log('üîß API Configuration:');\nconsole.log('üìç Base URL:', API_BASE_URL);\nconsole.log('üåç Environment:', \"development\");\nconsole.log('üìù Next Public API URL:', \"http://localhost:3000/api/v1\");\n// Configurar instancia de axios\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: 60000,\n    headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    },\n    withCredentials: false\n});\n// Interceptor para debug de requests\napiClient.interceptors.request.use((config)=>{\n    var _config_method;\n    console.log('üîç Request Debug:');\n    console.log('üìç URL:', config.url);\n    console.log('üåê Base URL:', config.baseURL);\n    console.log('üéØ Full URL:', \"\".concat(config.baseURL).concat(config.url));\n    console.log('üìù Method:', (_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase());\n    return config;\n}, (error)=>{\n    console.error('‚ùå Request Error:', error);\n    return Promise.reject(error);\n});\n// Interceptor para debug de responses\napiClient.interceptors.response.use((response)=>{\n    console.log('‚úÖ Response Success:', response.status, response.config.url);\n    return response;\n}, (error)=>{\n    var _error_config, _error_config1, _error_config2, _error_config3, _error_response, _error_response1;\n    console.error('‚ùå Response Error:');\n    console.error('üìç URL:', (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url);\n    console.error('üåê Base URL:', (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.baseURL);\n    console.error('üéØ Full URL:', \"\".concat((_error_config2 = error.config) === null || _error_config2 === void 0 ? void 0 : _error_config2.baseURL).concat((_error_config3 = error.config) === null || _error_config3 === void 0 ? void 0 : _error_config3.url));\n    console.error('üìä Status:', (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status);\n    console.error('üìÑ Response:', (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data);\n    return Promise.reject(error);\n});\n// Utilidad para obtener el progreso del backend (simplificada para Node.js backend)\nfunction getProgress(batchStatus) {\n    // El nuevo backend ya proporciona toda la informaci√≥n de progreso estructurada\n    return {\n        completed: batchStatus.progress.completed,\n        total: batchStatus.progress.total,\n        percentage: batchStatus.progress.percentage\n    };\n}\n// Servicios API\nclass ApiService {\n    /**\r\n   * Sube un archivo CSV al backend para procesamiento\r\n   * @param file - Archivo CSV a procesar\r\n   * @returns Respuesta con el batchId\r\n   */ static async uploadFile(file) {\n        const formData = new FormData();\n        formData.append('file', file);\n        try {\n            console.log('üöÄ Starting file upload:');\n            console.log('üìÑ File:', file.name, 'Size:', file.size, 'Type:', file.type);\n            console.log('üåê Full URL will be:', \"\".concat(API_BASE_URL, \"/scraping-batch\"));\n            console.log('üîó Axios baseURL:', apiClient.defaults.baseURL);\n            const response = await apiClient.post('/scraping-batch', formData, {\n                headers: {\n                    'Content-Type': 'multipart/form-data'\n                },\n                timeout: 120000,\n                onUploadProgress: (progressEvent)=>{\n                    if (progressEvent.total) {\n                        const percentCompleted = Math.round(progressEvent.loaded * 100 / progressEvent.total);\n                        console.log('Upload progress:', percentCompleted + '%');\n                    }\n                }\n            });\n            console.log('Upload successful:', response.data);\n            return response.data;\n        } catch (error) {\n            var _error_response, _error_response1, _error_response2, _error_response3, _error_response4, _error_response5, _error_message;\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('Upload error details:', {\n                message: error.message,\n                code: error.code,\n                status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n                statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n                data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data\n            });\n            // Manejo espec√≠fico de errores\n            if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n                throw new Error('‚ùå Backend server is not running on port 3000. Please start your backend server with: docker-compose up --build -d');\n            } else if (error.code === 'ECONNABORTED') {\n                throw new Error('‚è±Ô∏è Upload timeout - file too large or connection slow');\n            } else if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) === 413) {\n                throw new Error('üì¶ File too large');\n            } else if (((_error_response4 = error.response) === null || _error_response4 === void 0 ? void 0 : _error_response4.status) === 415) {\n                throw new Error('üìÑ Invalid file type - only CSV files are allowed');\n            } else if (((_error_response5 = error.response) === null || _error_response5 === void 0 ? void 0 : _error_response5.status) === 404) {\n                throw new Error('üîç Backend endpoint not found. Make sure backend is running and accessible.');\n            } else if (error.code === 'ERR_NETWORK' || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('CORS'))) {\n                throw new Error('üåê CORS Error: Backend needs CORS configuration. The backend is running but blocking browser requests.');\n            } else if (error.name === 'AxiosError' && !error.response) {\n                throw new Error('üîí Connection blocked - possible CORS issue. Backend is running but not accessible from browser.');\n            } else {\n                var _error_response_data, _error_response6;\n                throw new Error(((_error_response6 = error.response) === null || _error_response6 === void 0 ? void 0 : (_error_response_data = _error_response6.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || \"\\uD83D\\uDEAB Upload failed: \".concat(error.message));\n            }\n        }\n    }\n    /**\r\n   * Obtiene el estado actual de un batch de procesamiento\r\n   * @param batchId - ID del batch a consultar\r\n   * @returns Estado actual del batch\r\n   */ static async getBatchStatus(batchId) {\n        try {\n            const response = await apiClient.get(\"/scraping-batch/\".concat(batchId));\n            return response.data;\n        } catch (error) {\n            var _error_response;\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('Error fetching batch status:', error);\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404) {\n                throw new Error('‚ùì Batch not found. It may have expired or been processed.');\n            } else {\n                var _error_response_data, _error_response1;\n                throw new Error(\"Failed to fetch batch status: \".concat(((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message));\n            }\n        }\n    }\n    /**\r\n   * üÜï Exporta y descarga CSV limpio desde el backend\r\n   * @param batchId - ID del batch a exportar\r\n   * @returns void - Inicia descarga autom√°tica del archivo\r\n   */ static async exportCleanCSV(batchId) {\n        try {\n            console.log('üéØ Starting CSV export for batch:', batchId);\n            const response = await apiClient.get(\"/scraping-batch/\".concat(batchId, \"/export\"), {\n                responseType: 'blob',\n                headers: {\n                    'Accept': 'text/csv'\n                },\n                timeout: 60000\n            });\n            // Crear un blob y generar descarga autom√°tica\n            const blob = new Blob([\n                response.data\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const url = window.URL.createObjectURL(blob);\n            // Crear elemento de descarga temporal\n            const link = document.createElement('a');\n            link.href = url;\n            // Generar nombre de archivo con timestamp\n            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n            link.download = \"scraping-results-\".concat(timestamp, \".csv\");\n            // Agregar al DOM temporalmente y hacer click\n            document.body.appendChild(link);\n            link.click();\n            // Limpiar\n            document.body.removeChild(link);\n            window.URL.revokeObjectURL(url);\n            console.log('‚úÖ CSV exported successfully');\n        } catch (error) {\n            var _error_response, _error_response1;\n            (0,_debug__WEBPACK_IMPORTED_MODULE_0__.silentError)('CSV export error:', error);\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404) {\n                throw new Error('‚ùì Batch not found or expired');\n            } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 400) {\n                throw new Error('üö´ Batch not ready for export yet');\n            } else {\n                var _error_response_data, _error_response2;\n                throw new Error(\"\\uD83D\\uDEAB Export failed: \".concat(((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : (_error_response_data = _error_response2.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || error.message));\n            }\n        }\n    }\n    /**\r\n   * üÜï Valida el formato y contenido del archivo CSV\r\n   * @param file - Archivo CSV a validar\r\n   * @param t - Funci√≥n de traducci√≥n (opcional)\r\n   * @returns Resultado de la validaci√≥n\r\n   */ static async validateCSV(file, t) {\n        return new Promise((resolve)=>{\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                var _e_target;\n                const text = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result;\n                const lines = text.split('\\n').filter((line)=>line.trim());\n                if (lines.length === 0) {\n                    resolve({\n                        isValid: false,\n                        errors: [\n                            t ? t('csv.file_empty') : 'File is empty'\n                        ],\n                        warnings: [],\n                        rowCount: 0,\n                        columns: [],\n                        requiredColumns: [\n                            'name',\n                            'address',\n                            'city'\n                        ],\n                        missingColumns: [\n                            'name',\n                            'address',\n                            'city'\n                        ]\n                    });\n                    return;\n                }\n                // Parse header\n                const header = lines[0].split(',').map((col)=>col.trim().replace(/[\"']/g, ''));\n                const requiredColumns = [\n                    'name',\n                    'address',\n                    'city'\n                ];\n                const optionalColumns = [\n                    'postal_code'\n                ];\n                const allValidColumns = [\n                    ...requiredColumns,\n                    ...optionalColumns\n                ];\n                // Validaciones\n                const errors = [];\n                const warnings = [];\n                const missingColumns = requiredColumns.filter((col)=>!header.some((h)=>h.toLowerCase().includes(col.toLowerCase())));\n                // Validar columnas requeridas\n                if (missingColumns.length > 0) {\n                    errors.push(t ? t('csv.required_columns_missing', {\n                        columns: missingColumns.join(', ')\n                    }) : \"Missing required columns: \".concat(missingColumns.join(', ')));\n                }\n                // Validar n√∫mero m√≠nimo de filas\n                if (lines.length < 2) {\n                    errors.push(t ? t('csv.minimum_rows_required') : 'CSV must have at least one data row besides the header');\n                }\n                // Validar n√∫mero m√°ximo de filas (l√≠mite recomendado)\n                if (lines.length > 1001) {\n                    warnings.push(t ? t('csv.maximum_rows_warning', {\n                        count: lines.length - 1\n                    }) : \"File has \".concat(lines.length - 1, \" rows. Maximum 1000 recommended for better performance\"));\n                }\n                // Validar formato de datos (muestra de las primeras 5 filas)\n                const sampleRows = lines.slice(1, 6);\n                sampleRows.forEach((row, index)=>{\n                    const cells = row.split(',');\n                    if (cells.length !== header.length) {\n                        errors.push(t ? t('csv.column_mismatch', {\n                            row: index + 2,\n                            actual: cells.length,\n                            expected: header.length\n                        }) : \"Row \".concat(index + 2, \": Number of columns does not match header (\").concat(cells.length, \" vs \").concat(header.length, \")\"));\n                    }\n                    // Validar que el nombre no est√© vac√≠o\n                    const nameIndex = header.findIndex((h)=>h.toLowerCase().includes('name'));\n                    if (nameIndex >= 0 && (!cells[nameIndex] || cells[nameIndex].trim().replace(/[\"']/g, '') === '')) {\n                        errors.push(t ? t('csv.empty_business_name', {\n                            row: index + 2\n                        }) : \"Row \".concat(index + 2, \": Business name cannot be empty\"));\n                    }\n                });\n                resolve({\n                    isValid: errors.length === 0,\n                    errors,\n                    warnings,\n                    rowCount: lines.length - 1,\n                    columns: header,\n                    requiredColumns,\n                    missingColumns\n                });\n            };\n            reader.onerror = ()=>{\n                resolve({\n                    isValid: false,\n                    errors: [\n                        t ? t('csv.file_read_error') : 'Error reading file'\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columns: [],\n                    requiredColumns: [\n                        'name',\n                        'address',\n                        'city'\n                    ],\n                    missingColumns: [\n                        'name',\n                        'address',\n                        'city'\n                    ]\n                });\n            };\n            reader.readAsText(file);\n        });\n    }\n    /**\r\n   * üÜï Genera y descarga una plantilla CSV de ejemplo\r\n   * @returns void - Inicia descarga del archivo plantilla\r\n   */ static downloadCSVTemplate() {\n        const template = [\n            'name,address,city,postal_code',\n            'McDonald\\'s Bahnhofstrasse,\"Bahnhofstrasse 120\",Z√ºrich,8001',\n            'Starbucks Paradeplatz,\"Paradeplatz 4\",Z√ºrich,8001',\n            'Burger King Limmatquai,\"Limmatquai 66\",Z√ºrich,8001'\n        ].join('\\n');\n        const blob = new Blob([\n            template\n        ], {\n            type: 'text/csv;charset=utf-8;'\n        });\n        const url = window.URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = 'plantilla-scraping.csv';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url);\n        console.log('‚úÖ Plantilla CSV descargada');\n    }\n    /**\r\n   * üÜï Verifica el estado real de todos los servicios del backend\r\n   * @returns Estado detallado de cada servicio\r\n   */ static async checkServicesStatus() {\n        const result = {\n            api: false,\n            redis: false,\n            worker: false,\n            lastCheck: new Date().toISOString(),\n            error: undefined\n        };\n        try {\n            // 1. Verificar API (puerto 3000)\n            const apiResponse = await fetch('/health', {\n                method: 'GET',\n                timeout: 5000\n            });\n            result.api = apiResponse.ok && apiResponse.status === 200;\n            // 2. Si la API est√° up, verificar Redis y Worker a trav√©s de endpoints espec√≠ficos\n            if (result.api) {\n                try {\n                    // Verificar Redis a trav√©s de endpoint del API\n                    const redisResponse = await fetch('/health/redis', {\n                        method: 'GET',\n                        timeout: 3000\n                    });\n                    result.redis = redisResponse.ok;\n                } catch (e) {\n                    result.redis = false;\n                }\n                try {\n                    // Verificar Worker a trav√©s de endpoint del API\n                    const workerResponse = await fetch('/health/worker', {\n                        method: 'GET',\n                        timeout: 3000\n                    });\n                    result.worker = workerResponse.ok;\n                } catch (e) {\n                    result.worker = false;\n                }\n            }\n        } catch (error) {\n            result.error = error.message;\n            console.error('Error checking services:', error);\n        }\n        return result;\n    }\n    /**\r\n   * Verifica si el backend est√° disponible\r\n   * @returns true si el backend responde\r\n   */ static async healthCheck() {\n        try {\n            var _response_data;\n            // Usar proxy de Next.js en desarrollo, directo en producci√≥n\n            const healthUrl =  false ? 0 : '/health';\n            const healthClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n                timeout: 5000\n            });\n            // Usar endpoint /health seg√∫n documentaci√≥n del nuevo backend\n            const response = await healthClient.get(healthUrl);\n            console.log('‚úÖ Backend health check successful:', response.status, response.data);\n            return ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.status) === 'ok';\n        } catch (error) {\n            console.log('üî¥ Backend health check failed');\n            console.log('Error details:', error.message);\n            return false;\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDM0MsSUFBSTtnQkFhS2xIO1lBWlAsNkRBQTZEO1lBQzdELE1BQU1tSCxZQUFZeEksTUFBcUMsR0FDbkQsQ0FBOEIsR0FDOUI7WUFFSixNQUFNeUksZUFBZTVJLDZDQUFLQSxDQUFDUyxNQUFNLENBQUM7Z0JBQ2hDRSxTQUFTO1lBQ1g7WUFFQSw4REFBOEQ7WUFDOUQsTUFBTWEsV0FBVyxNQUFNb0gsYUFBYW5GLEdBQUcsQ0FBQ2tGO1lBQ3hDckksUUFBUUMsR0FBRyxDQUFDLHNDQUFzQ2lCLFNBQVNDLE1BQU0sRUFBRUQsU0FBU0UsSUFBSTtZQUNoRixPQUFPRixFQUFBQSxpQkFBQUEsU0FBU0UsSUFBSSxjQUFiRixxQ0FBQUEsZUFBZUMsTUFBTSxNQUFLO1FBQ25DLEVBQUUsT0FBT0osT0FBWTtZQUNuQmYsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxrQkFBa0JjLE1BQU02QixPQUFPO1lBQzNDLE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZGlsYW5cXERvY3VtZW50c1xcR2l0SHViXFxXZWItU2NyYXBwaW5nLUZyb250ZW5kXFxzcmNcXGxpYlxcYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcywgeyBBeGlvc0luc3RhbmNlLCBBeGlvc1Jlc3BvbnNlIH0gZnJvbSAnYXhpb3MnXHJcbmltcG9ydCB7IHNpbGVudExvZywgc2lsZW50RXJyb3IgfSBmcm9tICcuL2RlYnVnJ1xyXG5pbXBvcnQgeyBUcmFuc2xhdGlvbktleSB9IGZyb20gJ0AvaG9va3MvdXNlLXRyYW5zbGF0aW9uJ1xyXG5cclxuLy8gQmFzZSBVUkwgZGVsIGJhY2tlbmQgLSB1c2FyIHByb3h5IGRlIE5leHQuanMgZW4gZGVzYXJyb2xsbyBwYXJhIGV2aXRhciBDT1JTXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgXHJcbiAgPyAocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS92MScpXHJcbiAgOiAnL2FwaS92MScgLy8gVXNhciBwcm94eSBkZSBOZXh0LmpzIGVuIGRlc2Fycm9sbG9cclxuXHJcbmNvbnNvbGUubG9nKCfwn5SnIEFQSSBDb25maWd1cmF0aW9uOicpXHJcbmNvbnNvbGUubG9nKCfwn5ONIEJhc2UgVVJMOicsIEFQSV9CQVNFX1VSTClcclxuY29uc29sZS5sb2coJ/CfjI0gRW52aXJvbm1lbnQ6JywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXHJcbmNvbnNvbGUubG9nKCfwn5OdIE5leHQgUHVibGljIEFQSSBVUkw6JywgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTClcclxuXHJcbi8vIENvbmZpZ3VyYXIgaW5zdGFuY2lhIGRlIGF4aW9zXHJcbmNvbnN0IGFwaUNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxyXG4gIHRpbWVvdXQ6IDYwMDAwLCAvLyA2MCBzZWd1bmRvcyBwYXJhIHVwbG9hZHMgZ3JhbmRlc1xyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH0sXHJcbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSwgLy8gUGFyYSBldml0YXIgcHJvYmxlbWFzIGRlIENPUlNcclxufSlcclxuXHJcbi8vIEludGVyY2VwdG9yIHBhcmEgZGVidWcgZGUgcmVxdWVzdHNcclxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+UjSBSZXF1ZXN0IERlYnVnOicpXHJcbiAgICBjb25zb2xlLmxvZygn8J+TjSBVUkw6JywgY29uZmlnLnVybClcclxuICAgIGNvbnNvbGUubG9nKCfwn4yQIEJhc2UgVVJMOicsIGNvbmZpZy5iYXNlVVJMKVxyXG4gICAgY29uc29sZS5sb2coJ/Cfjq8gRnVsbCBVUkw6JywgYCR7Y29uZmlnLmJhc2VVUkx9JHtjb25maWcudXJsfWApXHJcbiAgICBjb25zb2xlLmxvZygn8J+TnSBNZXRob2Q6JywgY29uZmlnLm1ldGhvZD8udG9VcHBlckNhc2UoKSlcclxuICAgIHJldHVybiBjb25maWdcclxuICB9LFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIFJlcXVlc3QgRXJyb3I6JywgZXJyb3IpXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXHJcbiAgfVxyXG4pXHJcblxyXG4vLyBJbnRlcmNlcHRvciBwYXJhIGRlYnVnIGRlIHJlc3BvbnNlc1xyXG5hcGlDbGllbnQuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcclxuICAocmVzcG9uc2UpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKCfinIUgUmVzcG9uc2UgU3VjY2VzczonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmNvbmZpZy51cmwpXHJcbiAgICByZXR1cm4gcmVzcG9uc2VcclxuICB9LFxyXG4gIChlcnJvcikgPT4ge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIFJlc3BvbnNlIEVycm9yOicpXHJcbiAgICBjb25zb2xlLmVycm9yKCfwn5ONIFVSTDonLCBlcnJvci5jb25maWc/LnVybClcclxuICAgIGNvbnNvbGUuZXJyb3IoJ/CfjJAgQmFzZSBVUkw6JywgZXJyb3IuY29uZmlnPy5iYXNlVVJMKVxyXG4gICAgY29uc29sZS5lcnJvcign8J+OryBGdWxsIFVSTDonLCBgJHtlcnJvci5jb25maWc/LmJhc2VVUkx9JHtlcnJvci5jb25maWc/LnVybH1gKVxyXG4gICAgY29uc29sZS5lcnJvcign8J+TiiBTdGF0dXM6JywgZXJyb3IucmVzcG9uc2U/LnN0YXR1cylcclxuICAgIGNvbnNvbGUuZXJyb3IoJ/Cfk4QgUmVzcG9uc2U6JywgZXJyb3IucmVzcG9uc2U/LmRhdGEpXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXHJcbiAgfVxyXG4pXHJcblxyXG4vLyBJbnRlcmZhY2VzIHBhcmEgbGFzIHJlc3B1ZXN0YXMgZGVsIGJhY2tlbmRcclxuZXhwb3J0IGludGVyZmFjZSBCYXRjaFVwbG9hZFJlc3BvbnNlIHtcclxuICBiYXRjaElkOiBzdHJpbmdcclxuICBqb2JzQ3JlYXRlZDogbnVtYmVyXHJcbiAgbWVzc2FnZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hTdGF0dXMge1xyXG4gIGJhdGNoSWQ6IHN0cmluZ1xyXG4gIHN0YXR1czogJ3F1ZXVlZCcgfCAncHJvY2Vzc2luZycgfCAnY29tcGxldGVkJyB8ICdjb21wbGV0ZWRfd2l0aF9lcnJvcnMnXHJcbiAgcHJvZ3Jlc3M6IHtcclxuICAgIHRvdGFsOiBudW1iZXJcclxuICAgIGNvbXBsZXRlZDogbnVtYmVyXHJcbiAgICBmYWlsZWQ6IG51bWJlclxyXG4gICAgcHJvY2Vzc2luZzogbnVtYmVyXHJcbiAgICB3YWl0aW5nOiBudW1iZXJcclxuICAgIHBlcmNlbnRhZ2U6IG51bWJlclxyXG4gIH1cclxuICB0aW1pbmc6IHtcclxuICAgIGNyZWF0ZWRBdDogc3RyaW5nXHJcbiAgICBsYXN0UHJvY2Vzc2VkQXQ6IHN0cmluZ1xyXG4gICAgZXN0aW1hdGVkVGltZVJlbWFpbmluZzogc3RyaW5nIHwgbnVsbFxyXG4gIH1cclxuICByZXN1bHRzOiBTY3JhcGluZ1Jlc3VsdFtdXHJcbiAgc3VtbWFyeToge1xyXG4gICAgdG90YWxCdXNpbmVzc2VzOiBudW1iZXJcclxuICAgIHN1Y2Nlc3NmdWxTY3JhcGVzOiBudW1iZXJcclxuICAgIHBhcnRpYWxTY3JhcGVzOiBudW1iZXJcclxuICAgIGZhaWxlZFNjcmFwZXM6IG51bWJlclxyXG4gIH1cclxufVxyXG5cclxuLy8gSW50ZXJmYWNlIGZvciBzdWNjZXNzZnVsIHNjcmFwaW5nIHJlc3VsdHMgKFVwZGF0ZWQgZm9yIE5vZGUuanMgYmFja2VuZClcclxuZXhwb3J0IGludGVyZmFjZSBTY3JhcGluZ1Jlc3VsdCB7XHJcbiAgam9iSWQ6IHN0cmluZ1xyXG4gIFxyXG4gIC8vIElOUFVUIERBVEEgLSBPcmlnaW5hbCBkYXRhIGZyb20gQ1NWIGZpbGVcclxuICBvcmlnaW5hbERhdGE6IHtcclxuICAgIG5hbWU6IHN0cmluZ1xyXG4gICAgYWRkcmVzcz86IHN0cmluZ1xyXG4gICAgY2l0eT86IHN0cmluZ1xyXG4gICAgcG9zdGFsX2NvZGU/OiBzdHJpbmdcclxuICB9XHJcbiAgXHJcbiAgLy8gU0NSQVBFRCBEQVRBIC0gUmVhbCBkYXRhIGZvdW5kIG9uIEdvb2dsZSBNYXBzIChVcGRhdGVkIHdpdGggbmV3IGZpZWxkcylcclxuICBzY3JhcGVkRGF0YToge1xyXG4gICAgZnVsbE5hbWU/OiBzdHJpbmdcclxuICAgIGZ1bGxBZGRyZXNzPzogc3RyaW5nXHJcbiAgICBwaG9uZT86IHN0cmluZyB8IG51bGxcclxuICAgIHJhdGluZz86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgICAgICAgIC8vIOKtkCBORVc6IFJhdGluZy9DYWxpZmljYWNpw7NuXHJcbiAgICByZXZpZXdzQ291bnQ/OiBzdHJpbmcgfCBudWxsICAgICAgICAgICAgICAvLyDwn5OKIE5FVzogTsO6bWVybyBkZSByZXNlw7Fhc1xyXG4gICAgd2Vic2l0ZT86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgICAgICAgLy8g8J+MkCBORVc6IFNpdGlvIHdlYiBvZmljaWFsXHJcbiAgICBjYXRlZ29yeT86IHN0cmluZyB8IG51bGwgICAgICAgICAgICAgICAgICAvLyDwn4+377iPIE5FVzogQ2F0ZWdvcsOtYS90aXBvIGRlIG5lZ29jaW9cclxuICAgIHNvY2lhbE1lZGlhPzoge1xyXG4gICAgICBmYWNlYm9vaz86IHN0cmluZyB8IG51bGxcclxuICAgICAgaW5zdGFncmFtPzogc3RyaW5nIHwgbnVsbFxyXG4gICAgICB0d2l0dGVyPzogc3RyaW5nIHwgbnVsbFxyXG4gICAgICBsaW5rZWRpbj86IHN0cmluZyB8IG51bGxcclxuICAgICAgeW91dHViZT86IHN0cmluZyB8IG51bGxcclxuICAgIH1cclxuICAgIG9wZW5pbmdIb3Vycz86IHtcclxuICAgICAgW2RheTogc3RyaW5nXTogc3RyaW5nXHJcbiAgICB9XHJcbiAgICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdwYXJ0aWFsJyB8ICdmYWlsZWQnXHJcbiAgICBzY3JhcGVkQXQ6IHN0cmluZ1xyXG4gICAgZXJyb3I/OiBzdHJpbmcgfCBudWxsXHJcbiAgfSB8IG51bGxcclxuICBcclxuICAvLyBQUk9DRVNTSU5HIElORk9cclxuICBwcm9jZXNzaW5nVGltZTogbnVtYmVyXHJcbiAgcHJvY2Vzc2VkQXQ6IHN0cmluZ1xyXG4gIHdvcmtlcj86IG51bWJlclxyXG4gIGVycm9yPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnVzaW5lc3NIb3VycyB7XHJcbiAgbW9uZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgdHVlc2RheTogc3RyaW5nIHwgbnVsbFxyXG4gIHdlZG5lc2RheTogc3RyaW5nIHwgbnVsbFxyXG4gIHRodXJzZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgZnJpZGF5OiBzdHJpbmcgfCBudWxsXHJcbiAgc2F0dXJkYXk6IHN0cmluZyB8IG51bGxcclxuICBzdW5kYXk6IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuLy8g8J+GlSBJbnRlcmZhY2VzIHBhcmEgdmFsaWRhY2lvbmVzIHkgZXN0YWRvIGRlIHNlcnZpY2lvc1xyXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VTdGF0dXMge1xyXG4gIGFwaTogYm9vbGVhblxyXG4gIHJlZGlzOiBib29sZWFuXHJcbiAgd29ya2VyOiBib29sZWFuXHJcbiAgbGFzdENoZWNrOiBzdHJpbmdcclxuICBlcnJvcj86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENTVlZhbGlkYXRpb25SZXN1bHQge1xyXG4gIGlzVmFsaWQ6IGJvb2xlYW5cclxuICBlcnJvcnM6IHN0cmluZ1tdXHJcbiAgd2FybmluZ3M6IHN0cmluZ1tdXHJcbiAgcm93Q291bnQ6IG51bWJlclxyXG4gIGNvbHVtbnM6IHN0cmluZ1tdXHJcbiAgcmVxdWlyZWRDb2x1bW5zOiBzdHJpbmdbXVxyXG4gIG1pc3NpbmdDb2x1bW5zOiBzdHJpbmdbXVxyXG59XHJcblxyXG4vLyBVdGlsaWRhZCBwYXJhIG9idGVuZXIgZWwgcHJvZ3Jlc28gZGVsIGJhY2tlbmQgKHNpbXBsaWZpY2FkYSBwYXJhIE5vZGUuanMgYmFja2VuZClcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2dyZXNzKGJhdGNoU3RhdHVzOiBCYXRjaFN0YXR1cyk6IHsgY29tcGxldGVkOiBudW1iZXI7IHRvdGFsOiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9IHtcclxuICAvLyBFbCBudWV2byBiYWNrZW5kIHlhIHByb3BvcmNpb25hIHRvZGEgbGEgaW5mb3JtYWNpw7NuIGRlIHByb2dyZXNvIGVzdHJ1Y3R1cmFkYVxyXG4gIHJldHVybiB7XHJcbiAgICBjb21wbGV0ZWQ6IGJhdGNoU3RhdHVzLnByb2dyZXNzLmNvbXBsZXRlZCxcclxuICAgIHRvdGFsOiBiYXRjaFN0YXR1cy5wcm9ncmVzcy50b3RhbCxcclxuICAgIHBlcmNlbnRhZ2U6IGJhdGNoU3RhdHVzLnByb2dyZXNzLnBlcmNlbnRhZ2VcclxuICB9XHJcbn1cclxuXHJcbi8vIFNlcnZpY2lvcyBBUElcclxuZXhwb3J0IGNsYXNzIEFwaVNlcnZpY2Uge1xyXG4gIC8qKlxyXG4gICAqIFN1YmUgdW4gYXJjaGl2byBDU1YgYWwgYmFja2VuZCBwYXJhIHByb2Nlc2FtaWVudG9cclxuICAgKiBAcGFyYW0gZmlsZSAtIEFyY2hpdm8gQ1NWIGEgcHJvY2VzYXJcclxuICAgKiBAcmV0dXJucyBSZXNwdWVzdGEgY29uIGVsIGJhdGNoSWRcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgdXBsb2FkRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxCYXRjaFVwbG9hZFJlc3BvbnNlPiB7XHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXHJcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+agCBTdGFydGluZyBmaWxlIHVwbG9hZDonKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+ThCBGaWxlOicsIGZpbGUubmFtZSwgJ1NpemU6JywgZmlsZS5zaXplLCAnVHlwZTonLCBmaWxlLnR5cGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn4yQIEZ1bGwgVVJMIHdpbGwgYmU6JywgYCR7QVBJX0JBU0VfVVJMfS9zY3JhcGluZy1iYXRjaGApXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SXIEF4aW9zIGJhc2VVUkw6JywgYXBpQ2xpZW50LmRlZmF1bHRzLmJhc2VVUkwpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxCYXRjaFVwbG9hZFJlc3BvbnNlPiA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KCcvc2NyYXBpbmctYmF0Y2gnLCBmb3JtRGF0YSwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW1lb3V0OiAxMjAwMDAsIC8vIDIgbWludXRvcyBwYXJhIHVwbG9hZHNcclxuICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHByb2dyZXNzRXZlbnQudG90YWwpIHtcclxuICAgICAgICAgICAgY29uc3QgcGVyY2VudENvbXBsZXRlZCA9IE1hdGgucm91bmQoKHByb2dyZXNzRXZlbnQubG9hZGVkICogMTAwKSAvIHByb2dyZXNzRXZlbnQudG90YWwpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWQgcHJvZ3Jlc3M6JywgcGVyY2VudENvbXBsZXRlZCArICclJylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVXBsb2FkIHN1Y2Nlc3NmdWw6JywgcmVzcG9uc2UuZGF0YSlcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgc2lsZW50RXJyb3IoJ1VwbG9hZCBlcnJvciBkZXRhaWxzOicsIHtcclxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXHJcbiAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6IGVycm9yLnJlc3BvbnNlPy5zdGF0dXNUZXh0LFxyXG4gICAgICAgIGRhdGE6IGVycm9yLnJlc3BvbnNlPy5kYXRhXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyBNYW5lam8gZXNwZWPDrWZpY28gZGUgZXJyb3Jlc1xyXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVGVVNFRCcgfHwgZXJyb3IuY29kZSA9PT0gJ0VOT1RGT1VORCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+KdjCBCYWNrZW5kIHNlcnZlciBpcyBub3QgcnVubmluZyBvbiBwb3J0IDMwMDAuIFBsZWFzZSBzdGFydCB5b3VyIGJhY2tlbmQgc2VydmVyIHdpdGg6IGRvY2tlci1jb21wb3NlIHVwIC0tYnVpbGQgLWQnKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfij7HvuI8gVXBsb2FkIHRpbWVvdXQgLSBmaWxlIHRvbyBsYXJnZSBvciBjb25uZWN0aW9uIHNsb3cnKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQxMykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign8J+TpiBGaWxlIHRvbyBsYXJnZScpXHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDE1KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfwn5OEIEludmFsaWQgZmlsZSB0eXBlIC0gb25seSBDU1YgZmlsZXMgYXJlIGFsbG93ZWQnKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign8J+UjSBCYWNrZW5kIGVuZHBvaW50IG5vdCBmb3VuZC4gTWFrZSBzdXJlIGJhY2tlbmQgaXMgcnVubmluZyBhbmQgYWNjZXNzaWJsZS4nKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFUlJfTkVUV09SSycgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0NPUlMnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign8J+MkCBDT1JTIEVycm9yOiBCYWNrZW5kIG5lZWRzIENPUlMgY29uZmlndXJhdGlvbi4gVGhlIGJhY2tlbmQgaXMgcnVubmluZyBidXQgYmxvY2tpbmcgYnJvd3NlciByZXF1ZXN0cy4nKVxyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdBeGlvc0Vycm9yJyAmJiAhZXJyb3IucmVzcG9uc2UpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/CflJIgQ29ubmVjdGlvbiBibG9ja2VkIC0gcG9zc2libGUgQ09SUyBpc3N1ZS4gQmFja2VuZCBpcyBydW5uaW5nIGJ1dCBub3QgYWNjZXNzaWJsZSBmcm9tIGJyb3dzZXIuJylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgYPCfmqsgVXBsb2FkIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZWwgZXN0YWRvIGFjdHVhbCBkZSB1biBiYXRjaCBkZSBwcm9jZXNhbWllbnRvXHJcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBJRCBkZWwgYmF0Y2ggYSBjb25zdWx0YXJcclxuICAgKiBAcmV0dXJucyBFc3RhZG8gYWN0dWFsIGRlbCBiYXRjaFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBnZXRCYXRjaFN0YXR1cyhiYXRjaElkOiBzdHJpbmcpOiBQcm9taXNlPEJhdGNoU3RhdHVzPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxCYXRjaFN0YXR1cz4gPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfWApXHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHNpbGVudEVycm9yKCdFcnJvciBmZXRjaGluZyBiYXRjaCBzdGF0dXM6JywgZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfinZMgQmF0Y2ggbm90IGZvdW5kLiBJdCBtYXkgaGF2ZSBleHBpcmVkIG9yIGJlZW4gcHJvY2Vzc2VkLicpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYmF0Y2ggc3RhdHVzOiAke2Vycm9yLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2V9YClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICog8J+GlSBFeHBvcnRhIHkgZGVzY2FyZ2EgQ1NWIGxpbXBpbyBkZXNkZSBlbCBiYWNrZW5kXHJcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBJRCBkZWwgYmF0Y2ggYSBleHBvcnRhclxyXG4gICAqIEByZXR1cm5zIHZvaWQgLSBJbmljaWEgZGVzY2FyZ2EgYXV0b23DoXRpY2EgZGVsIGFyY2hpdm9cclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgZXhwb3J0Q2xlYW5DU1YoYmF0Y2hJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+OryBTdGFydGluZyBDU1YgZXhwb3J0IGZvciBiYXRjaDonLCBiYXRjaElkKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KGAvc2NyYXBpbmctYmF0Y2gvJHtiYXRjaElkfS9leHBvcnRgLCB7XHJcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYmxvYicsIC8vIEltcG9ydGFudGUgcGFyYSBhcmNoaXZvcyBiaW5hcmlvc1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9jc3YnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGltZW91dDogNjAwMDAsIC8vIDYwIHNlZ3VuZG9zIHBhcmEgZXhwb3J0YWNpw7NuXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBDcmVhciB1biBibG9iIHkgZ2VuZXJhciBkZXNjYXJnYSBhdXRvbcOhdGljYVxyXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3Jlc3BvbnNlLmRhdGFdLCB7IHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OycgfSlcclxuICAgICAgY29uc3QgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWFyIGVsZW1lbnRvIGRlIGRlc2NhcmdhIHRlbXBvcmFsXHJcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcclxuICAgICAgbGluay5ocmVmID0gdXJsXHJcbiAgICAgIFxyXG4gICAgICAvLyBHZW5lcmFyIG5vbWJyZSBkZSBhcmNoaXZvIGNvbiB0aW1lc3RhbXBcclxuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE5KS5yZXBsYWNlKC86L2csICctJylcclxuICAgICAgbGluay5kb3dubG9hZCA9IGBzY3JhcGluZy1yZXN1bHRzLSR7dGltZXN0YW1wfS5jc3ZgXHJcbiAgICAgIFxyXG4gICAgICAvLyBBZ3JlZ2FyIGFsIERPTSB0ZW1wb3JhbG1lbnRlIHkgaGFjZXIgY2xpY2tcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKVxyXG4gICAgICBsaW5rLmNsaWNrKClcclxuICAgICAgXHJcbiAgICAgIC8vIExpbXBpYXJcclxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxyXG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIENTViBleHBvcnRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBzaWxlbnRFcnJvcignQ1NWIGV4cG9ydCBlcnJvcjonLCBlcnJvcilcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+KdkyBCYXRjaCBub3QgZm91bmQgb3IgZXhwaXJlZCcpXHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfwn5qrIEJhdGNoIG5vdCByZWFkeSBmb3IgZXhwb3J0IHlldCcpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGDwn5qrIEV4cG9ydCBmYWlsZWQ6ICR7ZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZX1gKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiDwn4aVIFZhbGlkYSBlbCBmb3JtYXRvIHkgY29udGVuaWRvIGRlbCBhcmNoaXZvIENTVlxyXG4gICAqIEBwYXJhbSBmaWxlIC0gQXJjaGl2byBDU1YgYSB2YWxpZGFyXHJcbiAgICogQHBhcmFtIHQgLSBGdW5jacOzbiBkZSB0cmFkdWNjacOzbiAob3BjaW9uYWwpXHJcbiAgICogQHJldHVybnMgUmVzdWx0YWRvIGRlIGxhIHZhbGlkYWNpw7NuXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIHZhbGlkYXRlQ1NWKGZpbGU6IEZpbGUsIHQ/OiAoa2V5OiBUcmFuc2xhdGlvbktleSwgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPikgPT4gc3RyaW5nKTogUHJvbWlzZTxDU1ZWYWxpZGF0aW9uUmVzdWx0PiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxyXG4gICAgICBcclxuICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGUudGFyZ2V0Py5yZXN1bHQgYXMgc3RyaW5nXHJcbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSlcclxuICAgICAgICBcclxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yczogW3QgPyB0KCdjc3YuZmlsZV9lbXB0eScpIDogJ0ZpbGUgaXMgZW1wdHknXSxcclxuICAgICAgICAgICAgd2FybmluZ3M6IFtdLFxyXG4gICAgICAgICAgICByb3dDb3VudDogMCxcclxuICAgICAgICAgICAgY29sdW1uczogW10sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkQ29sdW1uczogWyduYW1lJywgJ2FkZHJlc3MnLCAnY2l0eSddLFxyXG4gICAgICAgICAgICBtaXNzaW5nQ29sdW1uczogWyduYW1lJywgJ2FkZHJlc3MnLCAnY2l0eSddXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFBhcnNlIGhlYWRlclxyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdLnNwbGl0KCcsJykubWFwKGNvbCA9PiBjb2wudHJpbSgpLnJlcGxhY2UoL1tcIiddL2csICcnKSlcclxuICAgICAgICBjb25zdCByZXF1aXJlZENvbHVtbnMgPSBbJ25hbWUnLCAnYWRkcmVzcycsICdjaXR5J11cclxuICAgICAgICBjb25zdCBvcHRpb25hbENvbHVtbnMgPSBbJ3Bvc3RhbF9jb2RlJ11cclxuICAgICAgICBjb25zdCBhbGxWYWxpZENvbHVtbnMgPSBbLi4ucmVxdWlyZWRDb2x1bW5zLCAuLi5vcHRpb25hbENvbHVtbnNdXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmFsaWRhY2lvbmVzXHJcbiAgICAgICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXHJcbiAgICAgICAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cclxuICAgICAgICBjb25zdCBtaXNzaW5nQ29sdW1ucyA9IHJlcXVpcmVkQ29sdW1ucy5maWx0ZXIoY29sID0+IFxyXG4gICAgICAgICAgIWhlYWRlci5zb21lKGggPT4gaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGNvbC50b0xvd2VyQ2FzZSgpKSlcclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmFsaWRhciBjb2x1bW5hcyByZXF1ZXJpZGFzXHJcbiAgICAgICAgaWYgKG1pc3NpbmdDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGVycm9ycy5wdXNoKHQgPyB0KCdjc3YucmVxdWlyZWRfY29sdW1uc19taXNzaW5nJywgeyBjb2x1bW5zOiBtaXNzaW5nQ29sdW1ucy5qb2luKCcsICcpIH0pIDogYE1pc3NpbmcgcmVxdWlyZWQgY29sdW1uczogJHttaXNzaW5nQ29sdW1ucy5qb2luKCcsICcpfWApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFZhbGlkYXIgbsO6bWVybyBtw61uaW1vIGRlIGZpbGFzXHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgIGVycm9ycy5wdXNoKHQgPyB0KCdjc3YubWluaW11bV9yb3dzX3JlcXVpcmVkJykgOiAnQ1NWIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZGF0YSByb3cgYmVzaWRlcyB0aGUgaGVhZGVyJylcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmFsaWRhciBuw7ptZXJvIG3DoXhpbW8gZGUgZmlsYXMgKGzDrW1pdGUgcmVjb21lbmRhZG8pXHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEwMDEpIHsgLy8gMTAwMCArIGhlYWRlclxyXG4gICAgICAgICAgd2FybmluZ3MucHVzaCh0ID8gdCgnY3N2Lm1heGltdW1fcm93c193YXJuaW5nJywgeyBjb3VudDogbGluZXMubGVuZ3RoIC0gMSB9KSA6IGBGaWxlIGhhcyAke2xpbmVzLmxlbmd0aCAtIDF9IHJvd3MuIE1heGltdW0gMTAwMCByZWNvbW1lbmRlZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlYClcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVmFsaWRhciBmb3JtYXRvIGRlIGRhdG9zIChtdWVzdHJhIGRlIGxhcyBwcmltZXJhcyA1IGZpbGFzKVxyXG4gICAgICAgIGNvbnN0IHNhbXBsZVJvd3MgPSBsaW5lcy5zbGljZSgxLCA2KVxyXG4gICAgICAgIHNhbXBsZVJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgY2VsbHMgPSByb3cuc3BsaXQoJywnKVxyXG4gICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCAhPT0gaGVhZGVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0ID8gdCgnY3N2LmNvbHVtbl9taXNtYXRjaCcsIHsgcm93OiBpbmRleCArIDIsIGFjdHVhbDogY2VsbHMubGVuZ3RoLCBleHBlY3RlZDogaGVhZGVyLmxlbmd0aCB9KSA6IGBSb3cgJHtpbmRleCArIDJ9OiBOdW1iZXIgb2YgY29sdW1ucyBkb2VzIG5vdCBtYXRjaCBoZWFkZXIgKCR7Y2VsbHMubGVuZ3RofSB2cyAke2hlYWRlci5sZW5ndGh9KWApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFZhbGlkYXIgcXVlIGVsIG5vbWJyZSBubyBlc3TDqSB2YWPDrW9cclxuICAgICAgICAgIGNvbnN0IG5hbWVJbmRleCA9IGhlYWRlci5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ25hbWUnKSlcclxuICAgICAgICAgIGlmIChuYW1lSW5kZXggPj0gMCAmJiAoIWNlbGxzW25hbWVJbmRleF0gfHwgY2VsbHNbbmFtZUluZGV4XS50cmltKCkucmVwbGFjZSgvW1wiJ10vZywgJycpID09PSAnJykpIHtcclxuICAgICAgICAgICAgZXJyb3JzLnB1c2godCA/IHQoJ2Nzdi5lbXB0eV9idXNpbmVzc19uYW1lJywgeyByb3c6IGluZGV4ICsgMiB9KSA6IGBSb3cgJHtpbmRleCArIDJ9OiBCdXNpbmVzcyBuYW1lIGNhbm5vdCBiZSBlbXB0eWApXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBcclxuICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXHJcbiAgICAgICAgICBlcnJvcnMsXHJcbiAgICAgICAgICB3YXJuaW5ncyxcclxuICAgICAgICAgIHJvd0NvdW50OiBsaW5lcy5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgY29sdW1uczogaGVhZGVyLFxyXG4gICAgICAgICAgcmVxdWlyZWRDb2x1bW5zLFxyXG4gICAgICAgICAgbWlzc2luZ0NvbHVtbnNcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICAgICAgZXJyb3JzOiBbdCA/IHQoJ2Nzdi5maWxlX3JlYWRfZXJyb3InKSA6ICdFcnJvciByZWFkaW5nIGZpbGUnXSxcclxuICAgICAgICAgIHdhcm5pbmdzOiBbXSxcclxuICAgICAgICAgIHJvd0NvdW50OiAwLFxyXG4gICAgICAgICAgY29sdW1uczogW10sXHJcbiAgICAgICAgICByZXF1aXJlZENvbHVtbnM6IFsnbmFtZScsICdhZGRyZXNzJywgJ2NpdHknXSxcclxuICAgICAgICAgIG1pc3NpbmdDb2x1bW5zOiBbJ25hbWUnLCAnYWRkcmVzcycsICdjaXR5J11cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIPCfhpUgR2VuZXJhIHkgZGVzY2FyZ2EgdW5hIHBsYW50aWxsYSBDU1YgZGUgZWplbXBsb1xyXG4gICAqIEByZXR1cm5zIHZvaWQgLSBJbmljaWEgZGVzY2FyZ2EgZGVsIGFyY2hpdm8gcGxhbnRpbGxhXHJcbiAgICovXHJcbiAgc3RhdGljIGRvd25sb2FkQ1NWVGVtcGxhdGUoKTogdm9pZCB7XHJcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IFtcclxuICAgICAgJ25hbWUsYWRkcmVzcyxjaXR5LHBvc3RhbF9jb2RlJyxcclxuICAgICAgJ01jRG9uYWxkXFwncyBCYWhuaG9mc3RyYXNzZSxcIkJhaG5ob2ZzdHJhc3NlIDEyMFwiLFrDvHJpY2gsODAwMScsXHJcbiAgICAgICdTdGFyYnVja3MgUGFyYWRlcGxhdHosXCJQYXJhZGVwbGF0eiA0XCIsWsO8cmljaCw4MDAxJyxcclxuICAgICAgJ0J1cmdlciBLaW5nIExpbW1hdHF1YWksXCJMaW1tYXRxdWFpIDY2XCIsWsO8cmljaCw4MDAxJ1xyXG4gICAgXS5qb2luKCdcXG4nKVxyXG4gICAgXHJcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3RlbXBsYXRlXSwgeyB0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtODsnIH0pXHJcbiAgICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxyXG4gICAgXHJcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXHJcbiAgICBsaW5rLmhyZWYgPSB1cmxcclxuICAgIGxpbmsuZG93bmxvYWQgPSAncGxhbnRpbGxhLXNjcmFwaW5nLmNzdidcclxuICAgIFxyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKVxyXG4gICAgbGluay5jbGljaygpXHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspXHJcbiAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCfinIUgUGxhbnRpbGxhIENTViBkZXNjYXJnYWRhJylcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIPCfhpUgVmVyaWZpY2EgZWwgZXN0YWRvIHJlYWwgZGUgdG9kb3MgbG9zIHNlcnZpY2lvcyBkZWwgYmFja2VuZFxyXG4gICAqIEByZXR1cm5zIEVzdGFkbyBkZXRhbGxhZG8gZGUgY2FkYSBzZXJ2aWNpb1xyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBjaGVja1NlcnZpY2VzU3RhdHVzKCk6IFByb21pc2U8U2VydmljZVN0YXR1cz4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBTZXJ2aWNlU3RhdHVzID0ge1xyXG4gICAgICBhcGk6IGZhbHNlLFxyXG4gICAgICByZWRpczogZmFsc2UsXHJcbiAgICAgIHdvcmtlcjogZmFsc2UsXHJcbiAgICAgIGxhc3RDaGVjazogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBlcnJvcjogdW5kZWZpbmVkXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIDEuIFZlcmlmaWNhciBBUEkgKHB1ZXJ0byAzMDAwKVxyXG4gICAgICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvaGVhbHRoJywge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgdGltZW91dDogNTAwMCxcclxuICAgICAgfSlcclxuICAgICAgcmVzdWx0LmFwaSA9IGFwaVJlc3BvbnNlLm9rICYmIGFwaVJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwXHJcbiAgICAgIFxyXG4gICAgICAvLyAyLiBTaSBsYSBBUEkgZXN0w6EgdXAsIHZlcmlmaWNhciBSZWRpcyB5IFdvcmtlciBhIHRyYXbDqXMgZGUgZW5kcG9pbnRzIGVzcGVjw61maWNvc1xyXG4gICAgICBpZiAocmVzdWx0LmFwaSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBWZXJpZmljYXIgUmVkaXMgYSB0cmF2w6lzIGRlIGVuZHBvaW50IGRlbCBBUElcclxuICAgICAgICAgIGNvbnN0IHJlZGlzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2hlYWx0aC9yZWRpcycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgdGltZW91dDogMzAwMCxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICByZXN1bHQucmVkaXMgPSByZWRpc1Jlc3BvbnNlLm9rXHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZXN1bHQucmVkaXMgPSBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gVmVyaWZpY2FyIFdvcmtlciBhIHRyYXbDqXMgZGUgZW5kcG9pbnQgZGVsIEFQSVxyXG4gICAgICAgICAgY29uc3Qgd29ya2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2hlYWx0aC93b3JrZXInLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDAsXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgcmVzdWx0LndvcmtlciA9IHdvcmtlclJlc3BvbnNlLm9rXHJcbiAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICByZXN1bHQud29ya2VyID0gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIHJlc3VsdC5lcnJvciA9IGVycm9yLm1lc3NhZ2VcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgc2VydmljZXM6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZlcmlmaWNhIHNpIGVsIGJhY2tlbmQgZXN0w6EgZGlzcG9uaWJsZVxyXG4gICAqIEByZXR1cm5zIHRydWUgc2kgZWwgYmFja2VuZCByZXNwb25kZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBoZWFsdGhDaGVjaygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzYXIgcHJveHkgZGUgTmV4dC5qcyBlbiBkZXNhcnJvbGxvLCBkaXJlY3RvIGVuIHByb2R1Y2Npw7NuXHJcbiAgICAgIGNvbnN0IGhlYWx0aFVybCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgXHJcbiAgICAgICAgPyAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2hlYWx0aCdcclxuICAgICAgICA6ICcvaGVhbHRoJ1xyXG4gICAgICBcclxuICAgICAgY29uc3QgaGVhbHRoQ2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcclxuICAgICAgICB0aW1lb3V0OiA1MDAwLFxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gVXNhciBlbmRwb2ludCAvaGVhbHRoIHNlZ8O6biBkb2N1bWVudGFjacOzbiBkZWwgbnVldm8gYmFja2VuZFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhlYWx0aENsaWVudC5nZXQoaGVhbHRoVXJsKVxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEJhY2tlbmQgaGVhbHRoIGNoZWNrIHN1Y2Nlc3NmdWw6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5kYXRhKVxyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YT8uc3RhdHVzID09PSAnb2snXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5S0IEJhY2tlbmQgaGVhbHRoIGNoZWNrIGZhaWxlZCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBkZXRhaWxzOicsIGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJheGlvcyIsInNpbGVudEVycm9yIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJjb25zb2xlIiwibG9nIiwiYXBpQ2xpZW50IiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwid2l0aENyZWRlbnRpYWxzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInVybCIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJkYXRhIiwiZ2V0UHJvZ3Jlc3MiLCJiYXRjaFN0YXR1cyIsImNvbXBsZXRlZCIsInByb2dyZXNzIiwidG90YWwiLCJwZXJjZW50YWdlIiwiQXBpU2VydmljZSIsInVwbG9hZEZpbGUiLCJmaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsIm5hbWUiLCJzaXplIiwidHlwZSIsImRlZmF1bHRzIiwicG9zdCIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJwcm9ncmVzc0V2ZW50IiwicGVyY2VudENvbXBsZXRlZCIsIk1hdGgiLCJyb3VuZCIsImxvYWRlZCIsIm1lc3NhZ2UiLCJjb2RlIiwic3RhdHVzVGV4dCIsIkVycm9yIiwiaW5jbHVkZXMiLCJnZXRCYXRjaFN0YXR1cyIsImJhdGNoSWQiLCJnZXQiLCJleHBvcnRDbGVhbkNTViIsInJlc3BvbnNlVHlwZSIsImJsb2IiLCJCbG9iIiwid2luZG93IiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInJlcGxhY2UiLCJkb3dubG9hZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJyZXZva2VPYmplY3RVUkwiLCJ2YWxpZGF0ZUNTViIsInQiLCJyZXNvbHZlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJ0ZXh0IiwidGFyZ2V0IiwicmVzdWx0IiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiaXNWYWxpZCIsImVycm9ycyIsIndhcm5pbmdzIiwicm93Q291bnQiLCJjb2x1bW5zIiwicmVxdWlyZWRDb2x1bW5zIiwibWlzc2luZ0NvbHVtbnMiLCJoZWFkZXIiLCJtYXAiLCJjb2wiLCJvcHRpb25hbENvbHVtbnMiLCJhbGxWYWxpZENvbHVtbnMiLCJzb21lIiwiaCIsInRvTG93ZXJDYXNlIiwicHVzaCIsImpvaW4iLCJjb3VudCIsInNhbXBsZVJvd3MiLCJmb3JFYWNoIiwicm93IiwiaW5kZXgiLCJjZWxscyIsImFjdHVhbCIsImV4cGVjdGVkIiwibmFtZUluZGV4IiwiZmluZEluZGV4Iiwib25lcnJvciIsInJlYWRBc1RleHQiLCJkb3dubG9hZENTVlRlbXBsYXRlIiwidGVtcGxhdGUiLCJjaGVja1NlcnZpY2VzU3RhdHVzIiwiYXBpIiwicmVkaXMiLCJ3b3JrZXIiLCJsYXN0Q2hlY2siLCJ1bmRlZmluZWQiLCJhcGlSZXNwb25zZSIsImZldGNoIiwib2siLCJyZWRpc1Jlc3BvbnNlIiwid29ya2VyUmVzcG9uc2UiLCJoZWFsdGhDaGVjayIsImhlYWx0aFVybCIsImhlYWx0aENsaWVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});